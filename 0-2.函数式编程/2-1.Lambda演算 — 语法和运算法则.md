# Lambda演算 — 语法和运算法则

计算机科学，尤其是编程语言，经常倾向于使用一种特定的演算：`Lambda`演算（`Lambda Calculus`）。这种演算也广泛地被逻辑学家用于学习计算和离散数学的结构的本质。`Lambda`演算伟大的的原因有很多，其中包括：

+ 非常简单。
+ 图灵完备。
+ 容易读写。
+ 语义足够强大，可以从它开始做（任意）推理。
+ 它有一个很好的实体模型。
+ 容易创建变种，以便我们探索各种构建计算或语义方式的属性。

`Lambda`演算易于读写，这一点很重要。它导致人们开发了很多极为优秀的编程语言，他们在不同程度上都基于`Lambda`演算：`LISP`，`ML`和`Haskell`语言都极度依赖于`Lambda`演算。

`Lambda`演算建立在函数的概念的基础上。纯粹的`Lambda`演算中，一切都是函数，连值的概念都没有。但是，我们可以用函数构建任何我们需要的东西。还记得在这个博客的初期，我谈了一些关于如何建立数学的方法么？ 我们可以从无到有地用`Lambda`演算建立数学的整个结构。

闲话少说，让我们深入的看一看`LC`（`Lambda Calculus`）。对于一个演算，需要定义两个东西：语法，它描述了如何在演算中写出合法的表达式；一组规则，让你符号化地操纵表达式。

## Lambda演算的语法

`Lambda`演算只有三类表达式：

+ 函数定义(`Function definetion`)：`Lambda` 演算中的函数是一个表达式，写成：`λx.body`，表示*一个参数参数为`x`的函数，它的返回值为`body`的计算结果*。这时我们说：`Lambda` 表达式绑定了参数`x`。
+ 标识符引用(`Identifier reference`)：标识符引用就是一个名字，这个名字匹配函数表达式中的某个参数名。
+ 函数应用(`Function application`)：函数应用指将函数应用于参数(前应用于后)，如`(λx.plus x x) y`。
  + 这里的 `plus` 相当于是我们全局声明的一个函数， `plus x x`应用了这个函数。
  + 而 `(λx.plus x x) y`将声明的函数表达式直接使用 `y `应用。
  + 除了全局的 `plus` 参数也可以被应用：`λy.(λx.x y)`。如果按照正常的编程思维我们必定会产生疑问，如果 `x` 不是一个函数怎么办，这就是 `lambda` 的神奇之处，万物皆函数。数字亦或是操作符都是不存在的。

### curry 柯里化

在 `Lambda` 演算中有一个技巧：如果你看一下上面的定义，你会发现一个函数（`Lambda` 表达式）只接受一个参数。这似乎是一个很大的局限 —— 你怎么能在只有一个参数的情况下实现加法？

这一点问题都没有，因为函数就是值。你可以写只有一个参数的函数，而这个函数返回一个带一个参数的函数，这样就可以实现写两个参数的函数了——本质上两者是一样的。这就是所谓的柯里化（Currying），以伟大的逻辑学家Haskell Curry命名。

例如我们想写一个函数来实现`x+y`。我们比较习惯写成类似：`λx y.plus x y`之类的东西。而采用单个参数函数的写法是：我们写一个只有一个参数的函数，让它返回另一个只有一个参数的函数。于是`x+y`就变成一个单参数`x`的函数，它返回另一个函数，这个函数将`x`加到它自己的参数上：

```lisp
λx.(λy.plus x y)
```

现在我们知道，添加多个参数的函数并没有真正添加任何东西，只不过简化了语法，所以下面继续介绍的时候，我会在方便的时候用到多参数函数。

### 自由变量 vs 绑定标识符

有一个重要的语法问题我还没有提到：闭包(`closure`)或者叫完全绑定(`complete binding`)。

在对一个 `Lambda` 演算表达式进行求值的时候，不能引用任何未绑定的标识符。

如果一个标识符是一个闭合 `Lambda`表达式的参数(完全绑定)，我们则称这个标识符是（被）绑定的；如果一个标识符在任何封闭上下文中都没有绑定，那么它被称为自由变量(闭包)。

+ `λx.plus x y`：在这个表达式中，`y`和`plus`是自由的，因为他们不是任何闭合的 `Lambda` 表达式的参数；而`x`是绑定的，因为它是函数定义的闭合表达式`plus x y`的参数。
+ `λx y.plus x y` ：在这个表达式中`x`和`y`都是被绑定的，因为它们都是函数定义中的参数。
+ `λy.(λx.plus x y)`：在内层演算`λx.plus x y`中，`y`和`plus`是自由的，`x`是绑定的。在完整表达中，`x`和`y`是绑定的：`x`受内层绑定，而`y`由剩下的演算绑定。`plus`仍然是自由的。

我们会经常使用`free(x)`来表示在表达式`x`中自由的标识符。

一个Lambda演算表达式只有在其所有变量都是绑定的时候才完全合法。但是，当我们脱开上下文，关注于一个复杂表达式的子表达式时，自由变量是允许存在的——这时候搞清楚子表达式中的哪些变量是自由的就显得非常重要了。

### 类比

`lambda` 演算中的一些基本规则，可以类比到我们比较熟悉的 `ES6` 语法:

|                  | lambda表达式          | ES6 箭头函数              |
| ---------------- | --------------------- | ------------------------- |
| 定义函数         | λx.x                  | x => x                    |
| 柯里化 curry     | λx. λy.plus x y       | x => y => x + y           |
| 应用 application | (λx. λy.plus x y) 5 1 | (x => y => x + y) (5) (1) |

## Lambda演算运算法则

`Lambda` 演算只有两条真正的法则：称为`Alpha`和`Beta`。`Alpha`也被称为「转换」，`Beta`也被称为「规约」。

### Alpha转换

`Alpha`是一个重命名操作; 基本上就是说，变量的名称是不重要的：给定`Lambda`演算中的任意表达式，我们可以修改函数参数的名称，只要我们同时修改函数体内所有对它的自由引用。

所以 —— 例如，如果有这样一个表达式：

```lisp
λx. if (= x 0) then 1 else x ^ 2 
```

我们可以用 `Alpha` 转换，将`x`变成`y`（写作`α[x / y]`），于是我们有：

```lisp
λy. if (= y 0) then 1 else y ^ 2 
```

这样丝毫不会改变表达式的含义。但是，正如我们将在后面看到的，这一点很重要，因为它使得我们可以实现比如递归之类的事情。

### Beta规约

`Beta`规约才是精彩的地方：这条规则使得`Lambda`演算能够执行任何可以由机器来完成的计算。

`Beta`基本上是说，如果你有一个函数应用，你可以对这个函数体中和**对应函数标识符相关的部分**做替换，替换方法是**把标识符用参数值替换**。这听起来很费解，但是它用起来却很容易。

假设我们有一个函数应用表达式：“ `(λx.plus x 1) 3` “。所谓 `Beta` 规约就是，我们可以通过替换函数体（“`plus x 1`”）来实现函数应用，用数值“`3`”取代引用的参数“`x`”。于是Beta规约的结果就是“`3 + 1`”。

一个稍微复杂的例子：`(λy.(λx.plus x y))q`。 这是一个挺有意思的表达式，因为应用这个`Lambda`表达式的结果是另一个`Lambda`表达式：也就是说，它是一个创建函数的函数。这时候的 `Beta`规约，需要用标识符“`q`”替换所有的引用参数“`y`”。所以，其结果是“ `λx.plus x q`“。

> 下文和部分上文我偷懒了，直接使用了一些本不应该存在的算术表达式和数字，这样不好，但是易于理解。不过请读这篇文章的你谨记，在 `lambda` 演算中万物皆函数，这些表达式和数字都是不存在的。

再给一个让你更不爽的例子：“ `(λx y.x y) (λz.z*z) 3` “。这是一个有两个参数的函数，它(的功能是)把第一个参数应用到第二个参数上。当我们运算时，我们替换第一个函数体中的参数“`x`”为“`λz.z*z` “；然后我们用“`3`”替换参数“`y`”，得到：“ `(λz.z*z) 3` “。 再执行`Beta`规约，有“`3*3`”。

`Beta` 规则的形式化写法为：

```lisp
λx.B e = B[x := e] if free(e) subset free(B[x := e]) 
```

最后的条件“`if free(e) subset free(B[x := e])`”说明了为什么我们需要`Alpha`转换：我们只有在不引起绑定标识符和自由标识符之间的任何冲突的情况下，才可以做`Beta`规约：如果标识符“`z`”在“`e`”中是自由的，那么我们就需要确保，`Beta`规约不会导致“`z`”变成绑定的。

如果在“`B`”中绑定的变量和“`e`”中的自由变量产生命名冲突，我们就需要用`Alpha`转换来更改标识符名称，使之不同。

###### **栗子🌰**

例子更能明确这一点：假设我们有一个函数表达式，“ `λz.(λx.x+z) `“，现在，假设我们要应用它：

```lisp
λz.(λx.x+z) (x+2)
```

参数“`(x + 2)`”中，`x`是自由的。现在，假设我们不遵守规则直接做 `Beta` 规约。我们会得到：

```lisp
λx.x+x+2 
```

原先在“`x + 2`”中自由的的变量现在被绑定了。再假设我们应用该函数：

```lisp
(λx.x+x+2) 3 
```

通过 `Beta` 规约，我们会得到“`3 + 3 + 2`”。

如果我们按照应有的方式先采用Alpha转换，又该如何？

+ 由 `alpha[x/y]` 有: `(λz.(λy.y+z)) (x+2)`；
+ 由`Beta`规约： `(λy.y+x+2) 3`；
+ 再由`Beta`规约： `3+x+2` ；

“`3 + x + 2`”和“`3 + 3 + 2`”是非常不同的结果！

### Eta规约

两个 `lambda` 算子若对于相同的输入产生相同的输出，则认为它们外延相等，可以互相规约。执行 `eta` 规约，`λx.f x`等价于`f`。对函数 `f` 逆用 `eta` 规约规则(`eta-expansion`)就可以将其展开成 `lambda` 表达式：`f = λx. f x`。

要理解eta规约规则需要注意的两点是：

+ `lambda` 演算中所有的东西都是函数（否则你可能问如果f是个整数怎么办），包括整数也是；
+ `lambda` 演算中只存在单参函数，多参的需求是用一种叫 `curry` 的方式“取巧”。

### 类比

如果用 `javascript` 来表示上述规则可以这么来书写：

```ts
/** Alpha */
x => x+x
// same as 
y => y+y
/** Beta */
(x => x+x)(1)
1+1
/** Eta */
x => f(x);
// same as
f
```

我在这里描述了一个图灵完备 —— 完整有效的计算系统。 要让它变得有用，或看它如何用来做些有实际意义的事情，我们还需要定义一堆能让我们做数学计算的基本函数，条件测试，递归等，我将在下一篇文章讨论这些。