# Lambda演算的算术

第一章我们说了，在**纯粹**的 `lambda`演算里面，没有所谓的数字和数学运算符(没有数字自然没有运算符)，如果我们需要他们只能由我们自己去实现。

所以，现在，让我们用`lambda`演算干点有趣的事。首先，为了方便起见，我将介绍些语法糖（`syntactic sugar`）来命名函数，以便下面遇到某些复杂的事情的时候方便我们阅读。

引进「全局」函数（即在我写的这些所有的关于`lambda`演算的介绍里都可以直接使用，而不用在每一个表达式中都声明一次这个函数的办法），我们将使用“`let`”表达式：

```lisp
let square = λx.x^2 
```

这条表达式声明了一个名为 `square` 的函数，其定义是`λx.x^2 `。如果我们有“ `square 4`”，则上面的“let”表达式的等效表达式为：

```lisp
(λsquare.square 4) (λx.x^2) 
```

## 阿隆佐.邱奇的天才之作 — 邱奇数

某些例子中，我使用了数字和算术运算。但数字并不真正存在于`lambda`演算中，我们有的只有函数！因此，我们需要发明某种使用函数来创建数字的方式。幸运的是，邱奇（`Alonzo Church`），这个发明了`lambda`演算的天才，找出了做到这一点的办法。他的函数化的数字的版本被称为邱奇数（`Church Numerals`）。

所有的丘奇数都是带有两个参数的函数：

+ `0`是 `λs z.z `；
+ `1`是 `λs z.s z` ；
+ `2`是 `λs z.s (s z)`；
+ 对于任何数`n`，它的邱奇数是将其第一个参数(函数)应用到第二个参数上`n`次的函数。

一个很好的理解办法是将“`z`”作为是对于零值的命名，而“`s`”作为后继函数的名称。

因此，`0` 是一个仅返回 `0` 值的函数；`1` 是将后继函数应用到 `0` 上 **一次的函数**；`2` 则是将后继函数应用到`1`上一次的函数，以此类推。

### 类比

有了理论的指导，我们很容易就能写出下面的代码：

```ts
const ZERO = f => x => x;
const ONE = f => x => f(x);
const TWO = f => x => f(f(x));
```

有了数字后，然后还需要再定义一个转换函数，它可以将`ZERO`和`ONE`这种函数式定义转成我们所熟悉的数字，方便调试。

```ts
const toNumber = n => n(i => i+1)(0);
console.log(toNumber(ONE));
// 1
```

## 加法

首先我们要实现的是四则运算中的加法：要做加法，`x + y`，我们需要写一个有四个参数的函数；两个需要相加的数字；以及推导数字时用到的“`s`”和“`z`”：

```lisp
let add = λs z x y.x s (y s z) 
```

让我们将其柯里化，看看是怎么回事。首先，它接受两个参数，这是我们需要做加法的两个值；第二，它需要正则化（`normalize`）这两个参数，以使它们都使用对0（`z`）和后继值（`s`）的绑定（即，将参数都写成`s`和`z`的组合的形式）。

```lisp
let add = λx y.(λs z.(x s (y s z))) 
```

看下这个式子，它说的是，为了将`x`和`y`相加，先用参数“`s`”和“`z`”创建（正则化的）丘奇数“`y`”。然后应用`x`到丘奇数`y`上，这时候使用由“`s`”和“`z`”定义的丘奇数`y`。也就是说，我们得到的结果是一个函数，这个函数把自己加到另一个数字上。（要计算`x + y`，先计算 `y` 是 `z` 的几号后继，然后计算`x` 是 `y`的几号后继。）

### 栗子🌰

让我们再进一步看看`1 + 2`的运算过程：

```ts
// 先来定义 1 和 2 
let ONE = λf1 x1.f1 x1;
let TWO = λf2 x2.f2 (f2 x2);
add ONE TWO s z;
```

将 `add` 函数展开来，并且对 `s` 和 `z` 做 `Beta` 规约：

```ts
(λx y.(λs z.(x s (y s z)))) TWO ONE
```

对已获得的表达式做 `Beta` 规约：

```ts
λs z.((λf2 x2.f2 (f2 x2)) s ((λf1 x1.f1 x1)  s z))
```

之后继续 `Beta` 规约数字 `1` ：

```ts
λs z.((λf2 x2.f2 (f2 x2)) s (s z))
```

然后beta规约丘奇数`2`。这步操作其实是“正则化”`2`：把数字`2`的定义里的后继函数和零函数替换成`add`的参数列表里的后继函数和零函数：

```ts
λs z.(s (s (s z)))
```

于是，我们的结果是：丘奇数`3`！

### 类比

将这段 `lambda` 表达式写成代码也很简单，想想一下两个邱奇数，将第二数应用于第一个数就可以获得累加的执行次数：

```ts
let add = (x) => (y) => (_f) => (_x) => x(_f)(y(_f)(_x));
```

## 乘法

再接下来我们来试着实现乘法，乘法照比加法也相对简单，同样是一个四个参数的函数：两个需要相乘的数字；以及推导数字时用到的“`s`”和“`z`”，我们只是调换了参数的位置就轻松实现了这个功能：

```ts
let mult = λx y s z.x (y s) z
```

同样让我们看看科里化的表示：

```tsx
let mult = λx.λy.λs.λz.x (y s) z
```

### 栗子🌰

让我们再进一步看看`2 * 2`的运算过程：

```ts
// 先来定义 1 和 2 
let TWO = λf2.λx2.f2 (f2 x2);
mult TWO TWO s z;
```

将 `mult` 函数展开来，并且对 `s` 和 `z` 做 `Beta` 规约：

```ts
(λx.λy.λs.λz.x (y s) z) TWO TWO
```

`TWO` 和 `TWO`对已获得的表达式做 `Beta` 规约：

```ts
λs.λz.(λf2.λx2.f2 (f2 x2)) ((λf2.λx2.f2 (f2 x2)) s) z
```

先使用第一个 `s` 对后一个 `TWO` 进行规约：

```ts
λs.λz.(λf2.λx2.f2 (f2 x2)) (λx2.s (s x2)) z
```

然后使用处理完的后一个 `TWO` 和 `z` 对 第一个 `TWO` 进行规约：

```ts
λs.λz.(λx2.s (s x2)) ((λx2.s (s x2)) z)
λs.λz.(λx2.s (s x2)) (s (s z))
```

最后我们的结果是：丘奇数`4`！

```ts
λs.λz.(s (s (s (s z))))
```

### 类比

跟上面同样的道理只要让任意一个数的 `f` 替换成另一个数的 `n(f)` 即可获得乘积的效果：

```ts
let mult = (x) => (y) => (_f) => (_x) => x(y(_f))(_x);
```

