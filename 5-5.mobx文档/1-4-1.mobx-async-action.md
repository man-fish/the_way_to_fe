# Asynchronous actions

ä»æœ¬è´¨ä¸Šè¯´ï¼Œ`MobX` ä¸­çš„å¼‚æ­¥è¿‡ç¨‹ä¸éœ€è¦ä»»ä½•ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸ºæ‰€æœ‰ `reaction` éƒ½æ˜¯è‡ªåŠ¨æ‰§è¡Œçš„(ä¸å¼‚æ­¥è¿”å›çš„æ—¶é—´ç‚¹æ— å…³)ï¼Œä¸è¿‡åœ¨å¼‚æ­¥æµç¨‹ä¸­æ›´æ–°å¯è§‚å¯Ÿå¯¹è±¡çš„æ¯ä¸ªæ­¥éª¤éƒ½åº”è¯¥æ ‡è®°ä¸º `action`ã€‚

`action` åŒ…è£…/è£…é¥°å™¨åªä¼šå¯¹å½“å‰è¿è¡Œçš„å‡½æ•°ä½œå‡ºååº”ï¼Œè€Œä¸ä¼šå¯¹å½“å‰è¿è¡Œå‡½æ•°æ‰€è°ƒç”¨çš„å‡½æ•°(ä¸åŒ…å«åœ¨å½“å‰å‡½æ•°ä¹‹å†…)ä½œå‡ºååº”ï¼ è¿™æ„å‘³ç€å¦‚æœ `action` ä¸­å­˜åœ¨ `setTimeout`ã€`promise` çš„ `then` æˆ– `async` è¯­å¥ï¼Œå¹¶ä¸”åœ¨å›è°ƒå‡½æ•°ä¸­æŸäº›çŠ¶æ€æ”¹å˜äº†ï¼Œé‚£ä¹ˆè¿™äº›å›è°ƒå‡½æ•°ä¹Ÿåº”è¯¥åŒ…è£…åœ¨ `action` ä¸­ã€‚

è¿™ä¸ªè¿‡ç¨‹å¯ä»¥é€šè¿‡å¤šç§æ–¹æ¡ˆå®ç°ï¼š

- `flow` **annotation**
- `flow(function* (args) { })`
- `async action(fn)`

## Still use Action

é¦–å…ˆæ¥çœ‹çœ‹ä»ç„¶ä½¿ç”¨ `action` çš„ä¾‹å­ï¼Œè¿™ç§å†™æ³•ä¸èƒ½å¾ˆå¥½çš„æ ‡è®°å¼‚æ­¥ `action`ï¼š

### Wrap handlers in `action`

è¿™æ˜¯æœ€ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œç»™éœ€è¦æ›´æ”¹å¯è§‚å¯Ÿå¯¹è±¡çš„ `promise` å¤„ç†å™¨åŒ…è£¹ `action`ï¼š

```ts
import { action, makeAutoObservable } from "mobx"

class Store {
    githubProjects = []
    state = "pending" // "pending", "done" or "error"

    constructor() {
        makeAutoObservable(this)
    }

    fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        fetchGithubProjectsSomehow().then(
            action("fetchSuccess", projects => {
                const filteredProjects = somePreprocessing(projects)
                this.githubProjects = filteredProjects
                this.state = "done"
            }),
            action("fetchError", error => {
                this.state = "error"
            })
        )
    }
}
```

### async/await + runInAction

å†…è”åŠ¨ä½œçš„ç¼ºç‚¹æ˜¯ `TypeScript` æ— æ³•å¯¹å…¶è¿›è¡Œç±»å‹æ¨å¯¼ï¼Œå°±æ˜¯æ²¡æ³•æŠŠå›è°ƒå‡½æ•°çš„ç±»å‹æŠ½ç¦»å‡ºæ¥ï¼Œè€Œæœ‰çš„æ—¶å€™ä½ å¯èƒ½éœ€è¦ä¸ºå›è°ƒå‡½æ•°å®šä¹‰ç±»å‹ã€‚

ä½ è¿˜å¯ä»¥åªåœ¨åŠ¨ä½œä¸­è¿è¡Œå›è°ƒå‡½æ•°ä¸­çŠ¶æ€ä¿®æ”¹çš„éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯ä¸º**æ•´ä¸ªå›è°ƒ**åˆ›å»ºä¸€ä¸ªåŠ¨ä½œã€‚è¿™ç§æ¨¡å¼çš„ä¼˜åŠ¿æ˜¯å®ƒé¼“åŠ±ä½ ä¸è¦åˆ°å¤„å†™ `action`ï¼Œè€Œæ˜¯åœ¨æ•´ä¸ªè¿‡ç¨‹ç»“æŸæ—¶å°½å¯èƒ½å¤šåœ°å¯¹æ‰€æœ‰çŠ¶æ€è¿›è¡Œä¿®æ”¹ï¼š

å¯¹äº `async/await` çš„å½¢å¼ï¼Œä½¿ç”¨ `runInAction`åŒ…è£¹æ‰§è¡Œæ‰§è¡Œæ›´æ–°çš„æ“ä½œï¼š

```ts
import { runInAction, makeAutoObservable } from "mobx"

class Store {
    githubProjects = []
    state = "pending" // "pending", "done" or "error"

    constructor() {
        makeAutoObservable(this)
    }

    async fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        try {
            const projects = await fetchGithubProjectsSomehow()
            const filteredProjects = somePreprocessing(projects)
            runInAction(() => {
                this.githubProjects = filteredProjects
                this.state = "done"
            })
        } catch (e) {
            runInAction(() => {
                this.state = "error"
            })
        }
    }
}
```

## Using flow instead of async / await {ğŸš€}

`makeautoobserve` å’Œç±»ä¼¼ `api`ï¼Œè‡ªåŠ¨æ¨æ–­ç”Ÿæˆå™¨ä¸ºæµç±»å‹ã€‚æµæ³¨è§£æˆå‘˜å°†æ˜¯**ä¸å¯æšä¸¾çš„**ã€‚

æµåŒ…è£…å™¨æ˜¯ `async / await` çš„ä¸€ä¸ªå¯é€‰æ›¿ä»£æ–¹æ¡ˆï¼Œå®ƒä½¿ `MobX` æ“ä½œæ›´å®¹æ˜“ã€‚`Flow` æ¥å—ç”Ÿæˆå™¨å‡½æ•°ä½œä¸ºå®ƒçš„å”¯ä¸€è¾“å…¥ã€‚å®ƒç›¸å½“äºæ˜¯ä¸€ä¸ª `generator` çš„è‡ªåŠ¨æ‰§è¡Œå™¨(ç±»ä¼¼`co`)ã€‚

åœ¨ç”Ÿæˆå™¨å†…éƒ¨ï¼Œæ‚¨å¯ä»¥é€šè¿‡ `yield` å®ƒä»¬æ¥ä¸²è” `promise`(ç”¨ `yield somePromise`ä»£æ›¿ `await somePromise`)ã€‚ç„¶åï¼Œæµæœºåˆ¶èƒ½åœ¨ `promise` è§£å†³(`resolved`)ä¹‹åï¼Œ`generator` ç»§ç»­æ‰§è¡Œæˆ–è€…æŠ›å‡ºé”™è¯¯ã€‚

å› æ­¤ï¼Œ`flow`æ˜¯ `async / await` çš„æ›¿ä»£æ–¹æ¡ˆï¼Œä¸éœ€è¦ä»»ä½•è¿›ä¸€æ­¥çš„æ“ä½œåŒ…è£…ã€‚å®ƒçš„åº”ç”¨æ–¹å¼å¦‚ä¸‹:

+ ä½¿ç”¨ `flow` åŒ…è£¹å¼‚æ­¥å‡½æ•°ã€‚
+ ä½¿ç”¨ `function *` ä»£æ›¿ `async`ã€‚
+ ä½¿ç”¨ `yield` ä»£æ›¿ `await`ã€‚

æ¥çœ‹ä¸€ä¸ªä½¿ç”¨ `flow`ä»£æ›¿å¼‚æ­¥`action`çš„æ–¹æ¡ˆï¼Œæ³¨æ„ä½¿ç”¨ `flow` åŒ…è£¹ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªåŒ…è£…åœ¨ `promise` ä¸­çš„ç”Ÿæˆå™¨è‡ªåŠ¨æ‰§è¡Œå™¨ï¼Œæ‰€ä»¥ç±»å¤–æ‰§è¡Œè¿™ä¸ªç”Ÿæˆå™¨å‡½æ•°éœ€è¦è°ƒç”¨ä¸€ä¸‹ `await`ï¼š

```ts
import { flow, makeAutoObservable, flowResult } from "mobx"

class Store {
    githubProjects = []
    state = "pending"

    constructor() {
        makeAutoObservable(this, {
            fetchProjects: flow
        })
    }

    // Note the star, this a generator function!
    *fetchProjects() {
        this.githubProjects = []
        this.state = "pending"
        try {
            // Yield instead of await.
            const projects = yield fetchGithubProjectsSomehow()
            const filteredProjects = somePreprocessing(projects)
            this.state = "done"
            this.githubProjects = filteredProjects
        } catch (error) {
            this.state = "error"
        }
    }
}

const store = new Store()
const projects = await store.fetchProjects()
```

### `flowResult(flowedFn)`

å¦‚æœæˆ‘ä»¬åœ¨ä½¿ç”¨ `typescript`ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨ `flow` æ³¨è§£çš„ç”Ÿæˆå™¨å‡½æ•°çš„æ—¶å€™éœ€è¦åŒ…è£¹ä¸€ä¸ª `flowResult` å‡½æ•°ã€‚

```ts
const projects = await flowResult(store.fetchProjects())
```

è¿™æ˜¯å› ä¸ºå‰é¢æˆ‘ä»¬è¯´äº†ï¼Œä½¿ç”¨ `flow` æ³¨è§£ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªåŒ…è£…åœ¨ `promise` ä¸­çš„ç”Ÿæˆå™¨è‡ªåŠ¨æ‰§è¡Œå™¨ã€‚

ç„¶è€Œï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯é€šè¿‡è£…é¥°å™¨å®ç°çš„ï¼Œ`TypeScript`å¹¶æ— æ³•è¯†åˆ«è¿™ç§è½¬æ¢ï¼Œåœ¨ `typescript` çœ¼é‡Œè¿™ä¸ª `fetchProjects` å‡½æ•°è¿˜æ˜¯ä¸€ä¸ªç”Ÿæˆå™¨ç±»å‹è€Œä¸æ˜¯è£…é¥°ä¹‹åè¿”å›çš„ `promise`ã€‚

æ‰€ä»¥ `flowResult` ä¼šç¡®ä¿ `TypeScript` æ£€æµ‹åˆ°è¿™ç§ç±»å‹çš„å˜åŒ–ï¼Œç›¸å½“äºæ˜¯ä¸€å±‚ç±»å‹æ¨æ–­ã€‚

### `flow.bound`

`flow.bound`æ³¨é‡Šå¯ç”¨äºè‡ªåŠ¨å°†æ–¹æ³•ç»‘å®šåˆ°æ­£ç¡®çš„å®ä¾‹ã€‚

## `flow(fn)`

`flow`å’Œ `action` ä¸€æ ·ï¼Œå¯ä»¥ç›´æ¥ç”¨äºåŒ…è£…å‡½æ•°ã€‚ä¸Šé¢çš„ä¾‹å­ä¹Ÿå¯ä»¥å†™æˆè¿™æ ·ï¼š

```ts
import { flow } from "mobx"

class Store {
    githubProjects = []
    state = "pending"

    fetchProjects = flow(function* (this: Store) {
        this.githubProjects = []
        this.state = "pending"
        try {
            // yield instead of await.
            const projects = yield fetchGithubProjectsSomehow()
            const filteredProjects = somePreprocessing(projects)
            this.state = "done"
            this.githubProjects = filteredProjects
        } catch (error) {
            this.state = "error"
        }
    })
}

const store = new Store()
const projects = await store.fetchProjects()
```

ä½¿ç”¨ `flow(fn)` è¿™ç§å½¢å¼çš„å¥½å¤„æ˜¯æˆ‘ä»¬ä¸éœ€è¦åœ¨ `typescript` ä¸­ä½¿ç”¨ `flowResult` åŒ…è£¹ `store.fetchProjects`ã€‚

## Cancelling flows {ğŸš€}

`flow` çš„å¦ä¸€ä¸ªä¼˜åŠ¿æ˜¯å®ƒä»¬æ˜¯å¯ä»¥å–æ¶ˆçš„ã€‚`flow` çš„è¿”å›å€¼æ˜¯ä¸€ä¸ª `promise`ï¼Œè¿™ä¸ª ``promise` çš„ `resolved` çŠ¶æ€çš„ç»“æœå€¼æ˜¯æœ€åä»ç”Ÿæˆå™¨å‡½æ•°è¿”å›çš„å€¼ã€‚

è¿”å›çš„ `promise` æœ‰ä¸€ä¸ªé¢å¤–çš„ `cancel()` æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°†ä¸­æ–­è¿è¡Œçš„ç”Ÿæˆå™¨(`generator`)å¹¶å–æ¶ˆå®ƒã€‚ä¸è¿‡ä»»ä½• `try / finally`å­å¥ä»ç„¶ä¼šè¿è¡Œã€‚



## Ts and flow

åœ¨ `ts` ä¸­ä½¿ç”¨ `flow` è¯­æ³•çš„æ—¶å€™å›ç¢°ä¸Šä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ä¸ªä½¿ç”¨å®ä¾‹é‡Œï¼Œæˆ‘ä»¬åœ¨ `yield promise` çš„æ—¶å€™ `ts` æŠ¥é”™äº†ï¼š

```ts
class QualifyStore {
   *fetchQualifyV2 (user_id: string) {
    // Wrap a promise in a simple generator retaining the return value's type
    try {
      this.qualifyLoading = true;
      const data = yield getUserQualify({user_id});
      					   // ^ 'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.
      this.qualifyInfo = {
        qualify_types: extractQualifyType(data ?? []),
        qualify: data
      };
    } catch (e) {
      this.pageError = true;
      $message.error(e.message || 'è·å–èµ„è´¨ä¿¡æ¯å¤±è´¥');
    } finally {
      this.qualifyLoading = false;
    }
  } 
}
```

å¦‚æœä½ ç†Ÿæ‚‰ç”Ÿæˆå™¨è¯­æ³•çš„è¯ï¼Œä½ å°±çŸ¥é“è¿™ä¸ªé”™è¯¯å…¶å®æ˜¯å¾ˆå¸¸è§çš„ï¼š

> å¦‚æœä¸ç»™ç”Ÿæˆå™¨å‡½æ•°ç±»å‹å£°æ˜çš„è¯ï¼Œ`next` çš„å‚æ•°åœ¨é»˜è®¤æƒ…å†µä¸‹æ¥æ”¶ä»»ä½•å‚æ•°(`any`)ï¼Œä¹Ÿå°±æ˜¯è¯´ `yield xx` çš„è¿”å›å€¼ä¸æ˜¯å¼ºçº¦æŸçš„ã€‚æ­¤æ—¶åœ¨ `ts` é‡Œä¼šæŠ¥é”™ï¼Œå¤§ä½“æ„æ€å°±æ˜¯ `yield` è¡¨è¾¾å¼çš„è¿”å›ç»“æœæ¶‰åŠåˆ° `any` ç±»å‹ç¼ºå°‘ä¸€ä¸ªç±»å‹æ–­è¨€ã€‚

è¦è§£å†³è¿™ä¸ªé—®é¢˜æœ‰ä¸¤ç§æ–¹æ¡ˆï¼Œç¬¬ä¸€ç§å¾ˆç›´æ¥ï¼Œæ²¡ç»™ç±»å‹å£°æ˜é‚£å°±ç»™ä¸€ä¸ªå˜›ï¼š

````ts
const data = (yield getUserQualify({user_id})) as Awaited<ReturnType<type getUserQualify>>
````

æˆ–è€…ä½ å¯ä»¥å°† `promsie` è½¬æ¢ä¸ºä¸€ä¸ª `Generator` å¹¶ä¸”ç»™ `yield*` æ¶ˆè´¹ï¼Œè¦å®ç°è¿™ç‚¹é¦–å…ˆæˆ‘ä»¬çŸ¥é“é€šè¿‡ `Generator` å®ç°çš„ `promise` å¼‚æ­¥å‡½æ•°å¤„ç†å…¶å®å°±æ˜¯ä¸€ä¸ªç»“æ„å›ºå®šçš„ç”Ÿæˆå™¨è‡ªåŠ¨æ‰§è¡Œå™¨ï¼Œæ¯”å¦‚ï¼š

```ts
function co(gen) {
  let g = gen();
  g.next().then(res => {
    g.next(res)
  })
  // ...
}
function* gen() {
  let res = yield doPromise();
  console.log(res);
}
```

æˆ‘ä»¬æ¯æ¬¡æ‹¿åˆ° `res` ä¼ é€’ç»™ `next` æŠŠå¼‚æ­¥å‡½æ•°çš„ç»“æœäº¤è¿˜ç»™ `generator` ä¸Šä¸‹æ–‡ã€‚

æ‰€ä»¥æƒ³è¦å†™ä¸€ä¸ªèƒ½ç»™ `yield*` æ¶ˆè´¹çš„ `promise` å…¶å®å¾ˆç®€å•ï¼Œé¦–å…ˆæˆ‘ä»¬å°† `async` å‡½æ•°åŒ…è£¹åœ¨ä¸€ä¸ªç”Ÿæˆå™¨å‡½æ•°é‡Œ(å› ä¸º `yield*` åªæ¥æ”¶ `iterator` ç»“æ„)ï¼Œç„¶åæˆ‘ä»¬ç»™ `yield doPromise()` ä¸€ä¸ªç±»å‹æ¨æ–­è¡¨ç¤ºæˆ‘ä»¬çš„ `TNext` åªæ¥æ”¶å¼‚æ­¥å‡½æ•°çš„ `resolve` å€¼ã€‚æœ€åå°†è¿™ä¸ª `res` è¿”å›ï¼Œè¿™æ ·æˆ‘ä»¬åŒ…è£¹çš„è¿™ä¸ªç”Ÿæˆå™¨çš„ `TReturn` å°±è¢«æ¨æ–­æˆäº†å¼‚æ­¥å‡½æ•°çš„ `resolve` å€¼ï¼Œå¹¶ä¸”ä¼šè¢« `yield*` æ¶ˆè´¹ã€‚

```ts
function toGen<R, Args extends any[]>(p: (...args: Args) => Promise<R>) {
  return function* (...args: Args) {
    // Generator<Promise<R>, R, R>;
    let res = (yield p(...args)) as R;
    return res; (yield p(...args)) as R;
    // return 
  };
}
```

è¿™å°±ç›¸å½“äºçº¦æŸäº† `yield p(..args)` çš„è¯­å¥çš„ç»“æœå€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬å¯¹è¿™ä¸ªç”Ÿæˆå™¨è¿›è¡Œ `next|return` æ“ä½œæ—¶çš„å‚æ•°å€¼æˆ–è€…ç»“æœå€¼åªèƒ½æ˜¯ `R`ã€‚

äºæ˜¯è¿™ä¸ª `promsie` å°±å¯ä»¥å½“åšæœ‰ `return` å€¼çš„ `generator` æ¥ä½¿ç”¨äº†ï¼š

```ts
function fetchQualifyV2* (user_id: string) {
  // Wrap a promise in a simple generator retaining the return value's type
  try {
    this.qualifyLoading = true;
    const data = yield* toGen(getUserQualify)({ user_id });
    this.qualifyInfo = {
      qualify_types: extractQualifyType(data ?? []),
      qualify: data
    };
  } catch (e) {
    this.pageError = true;
    $message.error(e.message || 'è·å–èµ„è´¨ä¿¡æ¯å¤±è´¥');
  } finally {
    this.qualifyLoading = false;
  }
}
```
