## ç´¢å¼•ç±»å‹ï¼ˆIndex typesï¼‰

ç´¢å¼•ç±»å‹æŒ‡çš„å°±æ˜¯æŸä¸ª `interface|obj` çš„ç´¢å¼•çš„ç±»å‹ï¼Œé€šå¸¸åˆ†ä¸ºä¸¤ä¸ªæ“ä½œï¼š**è·å–ç´¢å¼•ç±»å‹**å’Œ**ç´¢å¼•è®¿é—®**

```ts
interface Person {
    name: string;
    age: number;
}
// ç´¢å¼•ç±»å‹ 'name' | 'age'
// ç´¢å¼•è®¿é—® Person['name'] -> string
```

## ç´¢å¼•ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦

`keyof T`ï¼Œ **ç´¢å¼•ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦**ã€‚ å¯¹äºç±»å‹ `T`(åªèƒ½æ˜¯å¯¹è±¡ç±»å‹)ï¼Œ `keyof T`çš„ç»“æœä¸º `T`ä¸Šå·²çŸ¥çš„å…¬å…±å±æ€§åçš„è”åˆ(ä¸€ä¸ªå­—ç¬¦ä¸²æˆ–å®ƒçš„é”®çš„æ•°å­—æ–‡å­—è”åˆ(ä¸€ä¸ªç´¢å¼•ç±»å‹))ã€‚ ä¾‹å¦‚ï¼š

```ts
interface Person {
    name: string;
    age: number;
}

let personProps: keyof Person; // 'name' | 'age'
```

`keyof Person`æ˜¯å®Œå…¨å¯ä»¥ä¸ `'name' | 'age'`äº’ç›¸æ›¿æ¢çš„ã€‚å¦‚æœä½ æ·»åŠ äº†å…¶å®ƒçš„å±æ€§åˆ° `Person`ï¼Œä¾‹å¦‚ `address: string`ï¼Œé‚£ä¹ˆ `keyof Person`ä¼šè‡ªåŠ¨å˜ä¸º `'name' | 'age' | 'address'`ã€‚ 

å¦‚æœè¯¥ç±»å‹å…·æœ‰`string`æˆ–`number`ç´¢å¼•ç­¾åï¼Œ`keyof`åˆ™å°†è¿”å›è¿™äº›ç±»å‹ï¼š

```ts
type Arrayish = { [n: number]: unknown };
type A = keyof Arrayish;//   ^ = type A = number


type Mapish = { [k: string]: boolean };
type M = keyof Mapish;//   ^ = type M = string | number
```

ä¸Šé¢è¯´äº† `T` åªèƒ½æ˜¯å¯¹è±¡ç±»å‹ï¼Œä½†æ˜¯å…¶å®å¯¹ `string` ã€`number` ç±»ä¼¼è¿™æ ·çš„åŸºæœ¬ç±»å‹ä½¿ç”¨`keyof` ä¼šè¿”å›å®šä¹‰åœ¨å…¶åŒ…è£…ç±»å‹åŸå‹ä¸Šçš„å±æ€§æ–¹æ³•ï¼š

```ts
type t = keyof string;
// type t = number | "toString" | "charAt" | "charCodeAt" | "concat" | ... 40 more ... | "trimEnd"
```

## ç´¢å¼•è®¿é—®æ“ä½œç¬¦

ç¬¬äºŒä¸ªæ“ä½œç¬¦æ˜¯ `T[K]`ï¼Œ **ç´¢å¼•è®¿é—®æ“ä½œç¬¦**ã€‚ åœ¨è¿™é‡Œï¼Œç±»å‹è¯­æ³•åæ˜ äº†è¡¨è¾¾å¼è¯­æ³•ã€‚ è¿™æ„å‘³ç€ `person['name']`å…·æœ‰ç±»å‹ `Person['name']` â€” åœ¨æˆ‘ä»¬çš„ä¾‹å­é‡Œåˆ™ä¸º `string`ç±»å‹ã€‚

```ts
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
//   ^ = type Age = number
```

ç´¢å¼•ç±»å‹æœ¬èº«å°±æ˜¯ä¸€ç§ç±»å‹ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å®Œå…¨ä½¿ç”¨å¹¶é›†`keyof`ï¼Œæˆ–å…¶ä»–ç±»å‹ï¼š

```ts
type I1 = Person["age" | "name"];//   ^ = type I1 = string | number

type I2 = Person[keyof Person];//   ^ = type I2 = string | number | boolean

type AliveOrName = "alive" | "name";
type I3 = Person[AliveOrName];//   ^ = type I3 = string | boolean
```

 ç„¶è€Œï¼Œå°±åƒç´¢å¼•ç±»å‹æŸ¥è¯¢ä¸€æ ·ï¼Œä½ å¯ä»¥åœ¨æ™®é€šçš„ä¸Šä¸‹æ–‡é‡Œä½¿ç”¨ `T[K]`ï¼Œè¿™æ­£æ˜¯å®ƒçš„å¼ºå¤§æ‰€åœ¨ã€‚ ä½ åªè¦ç¡®ä¿ç±»å‹å˜é‡ `K extends keyof T`å°±å¯ä»¥äº†ã€‚ ä¾‹å¦‚ä¸‹é¢ `getProperty`å‡½æ•°çš„ä¾‹å­ï¼š

```ts
function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}
```

`getProperty`é‡Œçš„ `o: T`å’Œ `name: K`ï¼Œæ„å‘³ç€ `o[name]: T[K]`ã€‚ å½“ä½ è¿”å› `T[K]`çš„ç»“æœï¼Œç¼–è¯‘å™¨ä¼šå®ä¾‹åŒ–é”®çš„çœŸå®ç±»å‹ï¼Œå› æ­¤ `getProperty`çš„è¿”å›å€¼ç±»å‹ä¼šéšç€ä½ éœ€è¦çš„å±æ€§æ”¹å˜ã€‚

```ts
let name: string = getProperty(person, 'name');
let age: number = getProperty(person, 'age');
```

å¦‚æœå°è¯•ç´¢å¼•ä¸å­˜åœ¨çš„å±æ€§ï¼Œç”šè‡³ä¼šçœ‹åˆ°é”™è¯¯ï¼š

```ts
type I1 = Person["alve"];
// Property 'alve' does not exist on type 'Person'.
```

ä½¿ç”¨ä»»æ„ç±»å‹å»ºç«‹ç´¢å¼•çš„å¦ä¸€ä¸ªç¤ºä¾‹æ˜¯`number`ç”¨äºè·å–æ•°ç»„å…ƒç´ çš„ç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶ä¸`typeof`æ–¹ä¾¿åœ°æ•è·æ•°ç»„æ–‡å­—çš„å…ƒç´ ç±»å‹ç»“åˆèµ·æ¥ï¼š

```ts
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
];

type Person = typeof MyArray[number];//   ^ = type Person = {
//       name: string;
//       age: number;
//   }

type Age = typeof MyArray[number]["age"];//   ^ = type Age = number

// Or
type Age2 = Person["age"];//   ^ = type Age2 = number
```

### ä¸¾ä¸ªæ —å­ğŸŒ°

 ä¾‹å¦‚ï¼Œä¸€ä¸ªå¸¸è§çš„JavaScriptæ¨¡å¼æ˜¯ä»å¯¹è±¡ä¸­é€‰å–å±æ€§çš„å­é›†ã€‚

```js
function pluck(o, names) {
    return names.map(n => o[n]);
}
```

ä¸‹é¢æ˜¯å¦‚ä½•åœ¨ `TypeScript` é‡Œä½¿ç”¨æ­¤å‡½æ•°ï¼Œé€šè¿‡ **ç´¢å¼•ç±»å‹æŸ¥è¯¢**å’Œ **ç´¢å¼•è®¿é—®**æ“ä½œç¬¦ï¼š

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'Jarid',
    age: 35
};

let strings: string[] = pluck(person, ['name']); // ok, string[]
```

## æ•°ç»„ç±»å‹ç´¢å¼•

æ•°ç»„ç±»å‹ç´¢å¼•éƒ½æ˜¯ `numberString`ï¼Œåœ¨` typescript` å¯ä»¥é€šè¿‡ä¸€äº›ç‰¹æ®Šçš„æ“ä½œè¿›è¡Œè®¿é—®ï¼š

### `T[number]`

é€šè¿‡ä¸€ä¸ªç®€å•çš„ `T[number]` å¯ä»¥æ‹¿åˆ°ä¸€ä¸ªæ•°ç»„|å…ƒç»„ç±»å‹çš„ç±»å‹å¹¶é›†ï¼š

```ts
type Flatten<T extends readonly any[]> = T[number];

type ArrType = Flatten<['tesla', 'model 3', 'model X', 'model Y']>;
// type ArrType = "tesla" | "model 3" | "model X" | "model Y"
```

### `T['length']`

é€šè¿‡ `T['length']` è¿˜å¯ä»¥æ‹¿åˆ°æ•°ç»„é•¿åº¦å¯¹åº”çš„æ–‡å­—ç±»å‹ï¼š

```ts
type Length<T extends any[]> = T['length'];

type arr = [1, 2, 3];
type ArrLen = Length<arr>; // 3
```

### `T[i]`

é€šè¿‡ `t[i]`ç”šè‡³å¯ä»¥æ‹¿åˆ°ç‰¹å®šç´¢å¼•å¯¹åº”çš„å€¼ç±»å‹ï¼Œæ¯”å¦‚ä¸‹é¢æˆ‘ä»¬æ‹¿åˆ°æ•°ç»„çš„å¤´å…ƒç´ ï¼š

```ts
export type First<T extends any[]> = T[0];

type arr1 = ['a', 'b', 'c'];
type head1 = First<arr1>; 
// expected to be 'a'
```

å¦‚æœå¯¹åº”å…ƒç´ ä¸å­˜åœ¨åˆ™è¿”å›çš„æ˜¯ `undefined`ï¼š

```ts
type arr1 = [];
type head1 = First<arr1>; 
// expected to be undefined
```

## ç´¢å¼•ç±»å‹é‡ä¸Šå­—ç¬¦ä¸²ç´¢å¼•ç­¾å

`keyof`å’Œ `T[K]`ä¸å­—ç¬¦ä¸²ç´¢å¼•ç­¾åè¿›è¡Œäº¤äº’ã€‚ å¦‚æœä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å­—ç¬¦ä¸²ç´¢å¼•ç­¾åçš„ç±»å‹ï¼Œé‚£ä¹ˆ `keyof T`ä¼šæ˜¯ `string`ã€‚ å¹¶ä¸” `T[string]`ä¸ºç´¢å¼•ç­¾åçš„ç±»å‹ï¼š

```ts
interface Map<T> {
    [key: string]: T;
}
let keys: keyof Map<number>; // string
let value: Map<number>['foo']; // number
```

