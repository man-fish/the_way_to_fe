## ç´¢å¼•ç±»å‹ï¼ˆIndex typesï¼‰

ç´¢å¼•ç±»å‹æŒ‡çš„å°±æ˜¯æŸä¸ª `interface|obj` çš„ç´¢å¼•çš„ç±»å‹ï¼Œé€šå¸¸åˆ†ä¸ºä¸¤ä¸ªæ“ä½œï¼š**è·å–ç´¢å¼•ç±»å‹**å’Œ**ç´¢å¼•è®¿é—®**

```ts
interface Person {
    name: string;
    age: number;
}
// ç´¢å¼•ç±»å‹ 'name' | 'age'
// ç´¢å¼•è®¿é—® Person['name'] -> string
```

### ç´¢å¼•ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦

`keyof T`ï¼Œ **ç´¢å¼•ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦**ã€‚ å¯¹äºä»»ä½•ç±»å‹ `T`ï¼Œ `keyof T`çš„ç»“æœä¸º `T`ä¸Šå·²çŸ¥çš„å…¬å…±å±æ€§åçš„è”åˆã€‚ ä¾‹å¦‚ï¼š

```ts
interface Person {
    name: string;
    age: number;
}

let personProps: keyof Person; // 'name' | 'age'
```

`keyof Person`æ˜¯å®Œå…¨å¯ä»¥ä¸ `'name' | 'age'`äº’ç›¸æ›¿æ¢çš„ã€‚å¦‚æœä½ æ·»åŠ äº†å…¶å®ƒçš„å±æ€§åˆ° `Person`ï¼Œä¾‹å¦‚ `address: string`ï¼Œé‚£ä¹ˆ `keyof Person`ä¼šè‡ªåŠ¨å˜ä¸º `'name' | 'age' | 'address'`ã€‚ 

### ç´¢å¼•è®¿é—®æ“ä½œç¬¦

ç¬¬äºŒä¸ªæ“ä½œç¬¦æ˜¯ `T[K]`ï¼Œ **ç´¢å¼•è®¿é—®æ“ä½œç¬¦**ã€‚ åœ¨è¿™é‡Œï¼Œç±»å‹è¯­æ³•åæ˜ äº†è¡¨è¾¾å¼è¯­æ³•ã€‚ è¿™æ„å‘³ç€ `person['name']`å…·æœ‰ç±»å‹ `Person['name']` â€” åœ¨æˆ‘ä»¬çš„ä¾‹å­é‡Œåˆ™ä¸º `string`ç±»å‹ã€‚

 ç„¶è€Œï¼Œå°±åƒç´¢å¼•ç±»å‹æŸ¥è¯¢ä¸€æ ·ï¼Œä½ å¯ä»¥åœ¨æ™®é€šçš„ä¸Šä¸‹æ–‡é‡Œä½¿ç”¨ `T[K]`ï¼Œè¿™æ­£æ˜¯å®ƒçš„å¼ºå¤§æ‰€åœ¨ã€‚ ä½ åªè¦ç¡®ä¿ç±»å‹å˜é‡ `K extends keyof T`å°±å¯ä»¥äº†ã€‚ ä¾‹å¦‚ä¸‹é¢ `getProperty`å‡½æ•°çš„ä¾‹å­ï¼š

```ts
function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}
```

`getProperty`é‡Œçš„ `o: T`å’Œ `name: K`ï¼Œæ„å‘³ç€ `o[name]: T[K]`ã€‚ å½“ä½ è¿”å› `T[K]`çš„ç»“æœï¼Œç¼–è¯‘å™¨ä¼šå®ä¾‹åŒ–é”®çš„çœŸå®ç±»å‹ï¼Œå› æ­¤ `getProperty`çš„è¿”å›å€¼ç±»å‹ä¼šéšç€ä½ éœ€è¦çš„å±æ€§æ”¹å˜ã€‚

```ts
let name: string = getProperty(person, 'name');
let age: number = getProperty(person, 'age');
let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age'
```

### ä¸¾ä¸ªæ —å­ğŸŒ°

 ä¾‹å¦‚ï¼Œä¸€ä¸ªå¸¸è§çš„JavaScriptæ¨¡å¼æ˜¯ä»å¯¹è±¡ä¸­é€‰å–å±æ€§çš„å­é›†ã€‚

```js
function pluck(o, names) {
    return names.map(n => o[n]);
}
```

ä¸‹é¢æ˜¯å¦‚ä½•åœ¨ `TypeScript` é‡Œä½¿ç”¨æ­¤å‡½æ•°ï¼Œé€šè¿‡ **ç´¢å¼•ç±»å‹æŸ¥è¯¢**å’Œ **ç´¢å¼•è®¿é—®**æ“ä½œç¬¦ï¼š

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'Jarid',
    age: 35
};

let strings: string[] = pluck(person, ['name']); // ok, string[]
```

### ç´¢å¼•ç±»å‹é‡ä¸Šå­—ç¬¦ä¸²ç´¢å¼•ç­¾å

`keyof`å’Œ `T[K]`ä¸å­—ç¬¦ä¸²ç´¢å¼•ç­¾åè¿›è¡Œäº¤äº’ã€‚ å¦‚æœä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å­—ç¬¦ä¸²ç´¢å¼•ç­¾åçš„ç±»å‹ï¼Œé‚£ä¹ˆ `keyof T`ä¼šæ˜¯ `string`ã€‚ å¹¶ä¸” `T[string]`ä¸ºç´¢å¼•ç­¾åçš„ç±»å‹ï¼š

```ts
interface Map<T> {
    [key: string]: T;
}
let keys: keyof Map<number>; // string
let value: Map<number>['foo']; // number
```

## æ˜ å°„ç±»å‹

### `in` æ“ä½œç¬¦

æ¥çœ‹çœ‹æœ€ç®€å•çš„æ˜ å°„ç±»å‹å’Œå®ƒçš„ç»„æˆéƒ¨åˆ†ï¼š

```ts
type Keys = 'option1' | 'option2';
type Flags = { [K in Keys]: boolean };
```

`Keys` ç›¸å½“äºæ˜¯ç”¨ `keyof` æå–å‡ºæ¥çš„ä¸€ä¸ªç´¢å¼•æŸ¥è¯¢ç±»å‹ï¼Œä¸‹é¢çš„ `{ [K in Keys]: boolean };` ä¸­ `in` éå† `Keys`ï¼š

1. ç´¢å¼•ç±»å‹ä¼šä¾æ¬¡ç»‘å®šç”Ÿæˆå¤šä¸ªå±æ€§ï¼ˆ`Keys` é‡Œé¢åŒ…å«äº†å±æ€§åï¼‰ã€‚
2. å¹¶ä¸”å¯¹æ¯ä¸€ä¸ªå±æ€§åè®¾ç½®ä¸€ä¸ªå¯¹åº”çš„ç±»å‹ï¼ˆ`boolean`ï¼‰ã€‚

åœ¨ä¸ªç®€å•çš„ä¾‹å­é‡Œï¼Œ `Keys`æ˜¯ç¡¬ç¼–ç çš„çš„å±æ€§ååˆ—è¡¨å¹¶ä¸”å±æ€§ç±»å‹æ°¸è¿œæ˜¯ `boolean`ï¼Œå› æ­¤è¿™ä¸ªæ˜ å°„ç±»å‹ç­‰åŒäºï¼š

```ts
type Flags = {
    option1: boolean;
    option2: boolean;
}
```

### ä¸€ä¸ªæ —å­ğŸŒ°

ä¸€ä¸ªå¸¸è§çš„ä»»åŠ¡æ˜¯å°†ä¸€ä¸ªå·²çŸ¥çš„ç±»å‹æ¯ä¸ªå±æ€§éƒ½å˜ä¸ºå¯é€‰çš„ï¼š

```ts
interface PersonPartial {
    name?: string;
    age?: number;
}
```

æˆ–è€…æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªåªè¯»ç‰ˆæœ¬ï¼š

```ts
interface PersonReadonly {
    readonly name: string;
    readonly age: number;
}
```

è¿™åœ¨JavaScripté‡Œç»å¸¸å‡ºç°ï¼ŒTypeScriptæä¾›äº†ä»æ—§ç±»å‹ä¸­åˆ›å»ºæ–°ç±»å‹çš„ä¸€ç§æ–¹å¼ â€” **æ˜ å°„ç±»å‹**ã€‚ åœ¨æ˜ å°„ç±»å‹é‡Œï¼Œæ–°ç±»å‹ä»¥ç›¸åŒçš„å½¢å¼å»è½¬æ¢æ—§ç±»å‹é‡Œæ¯ä¸ªå±æ€§ã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä»¤æ¯ä¸ªå±æ€§æˆä¸º `readonly`ç±»å‹æˆ–å¯é€‰çš„ã€‚ ä¸‹é¢æ˜¯ä¸€äº›ä¾‹å­ï¼š

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
}
type Partial<T> = {
    [P in keyof T]?: T[P];
}
```

åƒä¸‹é¢è¿™æ ·ä½¿ç”¨ï¼š

```ts
type PersonPartial = Partial<Person>;
type ReadonlyPerson = Readonly<Person>;
```

é™¤äº†è¿™ä¸¤ä¸ªä¹‹å¤–è¿˜æœ‰ä¸€äº›å…¶ä»–çš„å¥½ç”¨çš„æ“ä½œå‡½æ•°ï¼š

```ts
type Nullable<T> = { [P in keyof T]: T[P] | null }
```

åœ¨è¿™äº›ä¾‹å­é‡Œï¼Œå±æ€§åˆ—è¡¨æ˜¯ `keyof T`ä¸”ç»“æœç±»å‹æ˜¯ `T[P]`æˆ–æ˜¯å…¶å˜ä½“ã€‚è¿™æ˜¯ä½¿ç”¨é€šç”¨æ˜ å°„ç±»å‹çš„ä¸€ä¸ªå¥½æ¨¡ç‰ˆã€‚ å› ä¸ºè¿™ç±»è½¬æ¢æ˜¯ [åŒæ€](https://en.wikipedia.org/wiki/Homomorphism)çš„ï¼Œæ˜ å°„åªä½œç”¨äº `T`çš„å±æ€§è€Œæ²¡æœ‰å…¶å®ƒçš„ã€‚ 

 ç¼–è¯‘å™¨çŸ¥é“åœ¨æ·»åŠ ä»»ä½•æ–°å±æ€§ä¹‹å‰å¯ä»¥æ‹·è´æ‰€æœ‰å­˜åœ¨çš„å±æ€§ä¿®é¥°ç¬¦ã€‚ ä¾‹å¦‚ï¼Œå‡è®¾ `Person.name`æ˜¯åªè¯»çš„ï¼Œé‚£ä¹ˆ `Partial<Person>.name`ä¹Ÿå°†æ˜¯åªè¯»çš„ä¸”ä¸ºå¯é€‰çš„ã€‚

```ts
type Record<K extends string, T> = {
    [P in K]: T;
}
```

`Readonly`ï¼Œ `Partial`å’Œ `Pick`æ˜¯åŒæ€çš„ï¼Œä½† `Record`ä¸æ˜¯ã€‚ å› ä¸º `Record`å¹¶ä¸éœ€è¦è¾“å…¥ç±»å‹æ¥æ‹·è´å±æ€§ï¼Œæ‰€ä»¥å®ƒä¸å±äºåŒæ€ï¼š

```ts
type ThreeStringProps = Record<'prop1' | 'prop2' | 'prop3', string>
```

éåŒæ€ç±»å‹æœ¬è´¨ä¸Šä¼šåˆ›å»ºæ–°çš„å±æ€§ï¼Œå› æ­¤å®ƒä»¬ä¸ä¼šä»å®ƒå¤„æ‹·è´å±æ€§ä¿®é¥°ç¬¦ã€‚

