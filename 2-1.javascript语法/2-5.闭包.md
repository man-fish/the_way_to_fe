## 闭包 Closure

------

闭包在 `javascript` 可以说是一个老生常谈的概念了，下面是我觉得对闭包最贴切的描述：**闭包是一个函数与它周围状态(词法环境)的引用捆绑在一起的封闭组合。**

![function - How do JavaScript closures work? - Stack Overflow](assets/OX92v.png)

换句话说，闭包使您可以从内部函数访问外部函数/全局的作用域。在 `JavaScript` 中，**每次创建函数时**都会在创建函数时创建闭包(无论这个函数是在另一个函数内部还是在全局)。

要使用闭包，我们需要在一个函数中定义另一个函数并**暴露这个内部函数**。要暴露一个函数，我们可以**返回它或将它传递给另一个函数**。

在外部函数返回之后，内部函数也可以访问外部函数作用域中的变量。

**外部作用域？**

这个外部作用域都包含什么呢？答案是参数、函数内声明的变量以及 `this`：

```ts
function OuterFunc(this: Caller, var1: {foo: string}) {
  let innerVar = 1;
  return () => {
    console.log(this, innerVar);
    var1.foo = 'zcc'
  }
}
let outerObj = {foo: 'bar'}
caller.OuterFunc(outerObj)();	// caller, 1
console.log(outerObj)					// {foo: 'zcc'}
```

### 闭包的实现

#### 返回闭包

先来举一个通过返回值构造闭包的例子：

```js
function OuterFunction() {

    var outerVariable = 100;

    function InnerFunction() {
        alert(outerVariable);
    }

    return InnerFunction;
}
var innerFunc = OuterFunction();

innerFunc(); // 100
```

在上面的例子中，`return InnerFunction;`当你调用 OuterFunction() 时，从 OuterFunction 返回 InnerFunction。变量`innerFunc `仅引用 InnerFunction()，而不引用 OuterFunction()。所以现在，当你调用innerFunc() 时，它仍然可以访问`outerVariable`在OuterFunction() 中声明的那个。这称为闭包。

#### 传递闭包

再来举一个通过传递函数的方式构建闭包，比如我们需要实现一个 `useLazyEffect` 函数，功能是构建一个第一次渲染不执行的 `useEffect`，如何实现呢？很简单我们只需要使用 `useState` 构建一个标志位，然后通过一个匿名函数形成闭包，并且以参数传递的方式将这个函数暴露出去：

```ts
function useLazyEffect(fn: (...args: never[]) => any, limit: any[]) {
    let [hasRendered, setHasRendered] = useState(false);

    useEffect(() => {
        if (!hasRendered) {
            setHasRendered(true);
            return;
        }
        fn();
    }, [limit]);
}

```

闭包在多个级别的内部函数中都是有效的。

```ts
function Counter() {
    
    var counter = 0;

    setTimeout( function () {
        var innerCounter = 0;
        counter += 1;
        alert("counter = " + counter);

        setTimeout( function () {
            counter += 1;
            innerCounter += 1;
            alert("counter = " + counter + ", innerCounter = " + innerCounter)
        }, 500);

    }, 1000);
};

Counter();
```

### 闭包特性

#### 值的引用

闭包的一个重要特性是外部变量可以在多次调用之间保持它们的状态。请记住，内部函数不会保留外部变量的单独副本，而是引用外部变量，这意味着如果您使用内部函数更改外部变量的值，它将更改它。

```ts
function Counter() {
    var counter = 0;

    function IncreaseCounter() {
        return counter += 1;
    };

    return IncreaseCounter;
}

var counter = Counter();
alert(counter()); // 1
alert(counter()); // 2
```

#### this

`this` 被我们看作是函数内一个隐式的存在，那么通过闭包内部函数能不能拿到外部函数的 `this` 呢？答案是不能。不过原因不是因为没有 `this` 的引用而是因为内部函数的 `this` 覆盖了外部函数的 `this`。

具体分析下面这段代码：

```ts
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    return function() {
      return this.name;
    };
  }
};

alert(object.getNameFunc()()); // The Windows
```

`getNameFunc` 的内部函数引用了 `this`，但是由于每个函数都有 `this` 所以可以理解成内部函数的 `this`(undefined)覆盖了外部的 `this`。而调用 `object.getNameFunc()()` 就想于是：

```js
let fn = object.getNameFunc();
fn(); // window.fn();
------
window.(object.getNameFunc())()
```

**胖箭头**

使用胖箭头可以解决这个问题，胖箭头式的匿名函数声明作用域内没有 `this` 不会产生覆盖，而是会通过闭包缓存外部的 `this`：

```js
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    return () => {
      return this.name;
    };
  }
};


alert(object.getNameFunc()());
```

**that**

用 `that` 缓存一个 `this` 也行：

```js
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    var that = this;
    return function(){
      return that.name;
    };
  }
};

alert(object.getNameFunc()());
```

