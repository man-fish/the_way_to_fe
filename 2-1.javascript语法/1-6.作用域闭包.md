## 6.闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 

```js
function foo() {
	var a = 2;
	return function() {
    console.log( a ); 
	}
}
var bar = foo(); 
bar(); // 2 —— 朋友，这就是闭包的效果。
```

`bar()` 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行 (也就是最后一行)。

在 `foo()` 执行后，`foo()` 的整个内部作用域通常都被销毁，因为我们知道引擎有垃圾回收器来释放不再使用的内存空间。而闭包可以以阻止这件事情的发生。事实上 `foo` 的内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 `bar()` 本身在使用。 

所以这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 实际上只要使用了回调函数，实际上就是在使用闭包！ 

### 循环和闭包

这段代码在运行时会以每秒一次的频率输出五次 6。 

```js
for (var i=1; i<=5; i++) { 
  setTimeout( function timer() { 
    console.log( i ); 
  }, i*1000 ); 
}
```

这是因为延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 `setTimeout(.., 0)`，所有的回调函数依然是在循环结束后才会被执行，根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 `i`。 

`IIFE` 会通过声明并立即执行一个函数来创建作用域，这样会实现正常的输出么？

```js
for (var i=1; i<=5; i++) { 
  (function() { 
    setTimeout( function timer() { 
      console.log( i ); }, i*1000 ); 
  })(); 
}
```

的确每个延迟函数都会将 `IIFE` 在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。我们的 `IIFE` 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。 

它需要有自己的变量，用来在每个迭代中储存 `i` 的值：

```js
for (var i=1; i<=5; i++) { 
  (function(j) { 
    setTimeout(function timer() { 
      console.log( j ); }, i*1000 ); 
  })(i); 
}
```

在迭代内使用 `IIFE` 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

而 `for` 循环头部的 `let` 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

```js
for (let i=1; i<=5; i++) { 
  setTimeout( 
    function timer() { console.log( i ); }, i*1000 
  ); 
}
```

