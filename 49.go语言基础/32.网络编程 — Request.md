# Request ğŸ«

`http.Request`ä¸€ä¸ªé€šç”¨çš„httpè¯·æ±‚æµæ¥å£ï¼Œä»–å‡ºç°åœ¨`func HandleFunc (w http.ResponseWriter,r *http.Request)`å’Œ`func NewRequest(method, url string, body io.Reader) (*Request, error)`çš„è¿”å›å€¼ä¸­ï¼Œä½œä¸ºä¸€ä¸ªè´Ÿè´£è¯·æ±‚æµä¹¦å†™å’Œè§£æçš„å¯¹è±¡ã€‚

## ç»“æ„ä½“

```go
type Request struct {
	Method string
    Proto string
    Host string
    RequestURI string
    Header Header
	URL *url.URL
	Body io.ReadCloser
	ContentLength int64
	PostForm url.Values
	MultipartForm *multipart.Form
}
```



### Methodã€Protoã€Hostã€RequestURI

è¿™äº›å­—æ®µåœ¨`HandleFunc`ä¸­ç”¨ä½œè§£æè¯·æ±‚æµï¼Œåœ¨ `NewRequest`è´Ÿè´£æ„å»ºè¯·æ±‚æµï¼ˆæ ¹æ®ä½ ä¼ å…¥çš„URLè‡ªåŠ¨æ„å»ºï¼‰ã€‚

```go
Method 		POST		//è¯·æ±‚æ–¹å¼
URL 		/id?i=1		//è·¯å¾„+å‚æ•°
Proto 		HTTP/1.1	//åè®®ç‰ˆæœ¬å·
Host 		127.0.0.1:3000	//è¯·æ±‚ä¸»æœºå
RequestURI 	/id?i=1		//è·¯å¾„+å‚æ•°
```



### Header

`Header`å­—æ®µæ˜¯ä¸€ä¸ªmapç±»å‹ï¼Œåœ¨`HandleFunc`ä¸­ç”¨ä½œè§£æè¯·æ±‚å¤´ï¼Œåœ¨ `NewRequest`è´Ÿè´£æ„å»ºè¯·æ±‚å¤´ã€‚

```go
type Header map[string][]string

func (h Header) Add(key, value string) {
	textproto.MIMEHeader(h).Add(key, value)
}

func (h Header) Set(key, value string) {
	textproto.MIMEHeader(h).Set(key, value)
}

func (h Header) Get(key string) string {
	return textproto.MIMEHeader(h).Get(key)
}

func (h Header) Del(key string) {
	textproto.MIMEHeader(h).Del(key)
}
```

###### NewRequestç¤ºä¾‹

```go
req, _ := http.NewRequest("POST", "http://example.com", strings.NewReader(data))
req.Header.Add("If-None-Match", `W/"wyzzy"`)
```



### URL

`URL`å­—æ®µå…¶å®æ˜¯ä¸€ä¸ª`url.URL`ç»“æ„ä½“ï¼Œåœ¨`HandleFunc`ä¸­ç”¨ä½œè§£æè¯·æ±‚å¤´ï¼Œåœ¨ `NewRequest`è´Ÿè´£æ„å»ºè¯·æ±‚å‚æ•°ï¼ˆåæ–‡ä¼šè¯´ï¼‰ã€‚

#### URLç»“æ„ä½“æ ¼å¼

```go
type URL struct {
	Scheme     string    // no use
	Opaque     string    // no use
	User       *Userinfo // no use
    RawPath    string    // no use
    Fragment   string    // fragment for references, without '#'	no use
    ForceQuery bool      // append a query ('?') even if RawQuery is empty   no use
	Host       string    // host or host:port
	Path       string    // pathname without query
	RawQuery   string    // encoded query values, without '? like 'id=1&love=1
}
```

###### Stringæ–¹æ³•

```go
func (u *URL) String() string
```

###### Queryæ–¹æ³•

è¿”å›çš„æ˜¯ä¸€ä¸ªurl.Valueså¯ä»¥è°ƒç”¨getå’Œsetæ–¹æ³•

```go
func (u *URL) Query() Values {   v, _ := ParseQuery(u.RawQuery)   return v}
```

#### url.Values ç±»å‹

> å…¶å®æ˜¯ä¸€ä¸ªç±»å‹åˆ«å
>
> - type Values map[string][]string

###### Setæ–¹æ³•

```go
func (v Values) Set(key, value string) {
	v[key] = []string{value}
}
```

###### Addæ–¹æ³•

```go
func (v Values) Add(key, value string) {
	v[key] = append(v[key], value)
}
```

###### Encodeæ–¹æ³•

```go
func (v Values) Encode() string
```

#### HandleFuncè§£æGetè¯·æ±‚å®ä¾‹

```go
func getHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	data := r.URL.Query()
	fmt.Println(data.Get("name"))
	fmt.Println(data.Get("age"))
	answer := `{"status": "ok"}`
	w.Write([]byte(answer))
}
```



### Bodyã€ContentLength

ä¸ç®¡æ˜¯åˆ›å»ºè¿˜æ˜¯è§£æè¯·æ±‚æµçš„æ—¶å€™`Body`éƒ½æ˜¯çœŸæ­£å­˜å‚¨æ•°æ®çš„åœ°æ–¹ï¼ˆé™¤äº†GETè¯·æ±‚ï¼‰ï¼Œå®ƒæ˜¯ä¸€ä¸ª`IO.ReadCloser`å¯¹è±¡æä¾›äº†`Read`æ¥å£ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¯»å–å…¶å†…å®¹ï¼ˆå­—èŠ‚æ•°ç»„ï¼‰ã€‚

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	// 1. è¯·æ±‚ç±»å‹æ˜¯application/x-www-form-urlencodedæ—¶è§£æformæ•°æ®
	r.ParseForm()
	fmt.Println(r.PostForm) // æ‰“å°formæ•°æ®
	fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))
	// 2. è¯·æ±‚ç±»å‹æ˜¯application/jsonæ—¶ä»r.Bodyè¯»å–æ•°æ®
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Println("read request.Body failed, err:%v\n", err)
		return
	}
	fmt.Println(string(b))
	answer := `{"status": "ok"}`
	w.Write([]byte(answer))
}
```



### PostForm

å½“æˆ‘ä»¬çš„è¯·æ±‚ç±»å‹æ˜¯`application/x-www-form-urlencoded`æ—¶è§£ææˆ‘ä»¬é€šå¸¸éœ€è¦è§£æè¿™æ ·çš„`Form`æ•°æ®`id=1&name=2`ï¼Œ`go`ä¸ºæˆ‘ä»¬æä¾›äº†å†…ç½®å‡½æ•°æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒPostFormå†…éƒ¨ä¹Ÿæ˜¯url.Valuesç±»å‹

```go
type Values map[string][]string
```

###### è§£æè¡¨å•è¯·æ±‚

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	r.ParseForm()
    // è¯·æ±‚ç±»å‹æ˜¯application/x-www-form-urlencodedæ—¶è§£æformæ•°æ®
	fmt.Println(r.PostForm) 
    // æ‰“å°formæ•°æ®
	fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))
    // è·å–formæ•°æ®
}
```



### MultipartForm

è¿™ä¸ªä¸äºˆèµ˜è¿°ï¼Œå½“æˆ‘ä»¬æ–‡ä»¶ä¸Šä¼ æ—¶ç”¨æ¥è§£ææ–‡ä»¶ï¼Œä½¿ç”¨åŸç†å’Œ`PostForm`å·®ä¸å¤š

```go
type Form struct {
	Value map[string][]string
	File  map[string][]*FileHeader
}
```

## æ¥æ”¶è€…æ–¹æ³•

### io.Writerçš„Writeæ–¹æ³•

```
func (r *Request) Write(w io.Writer) error {
	return r.write(w, false, nil, nil)
}
```

### Cookieç›¸å…³æ–¹æ³•

```go
func (r Request) Cookies() []Cookie {
	return readCookies(r.Header, "")
}

var ErrNoCookie = errors.New("http: named cookie not present")

func (r Request) Cookie(name string) (Cookie, error) {
	for _, c := range readCookies(r.Header, name) {
		return c, nil
	}
	return nil, ErrNoCookie
}

func (r *Request) AddCookie(c *Cookie) {
	s := fmt.Sprintf("%s=%s", sanitizeCookieName(c.Name), sanitizeCookieValue(c.Value))
	if c := r.Header.Get("Cookie"); c != "" {
		r.Header.Set("Cookie", c+"; "+s)
	} else {
		r.Header.Set("Cookie", s)
	}
}
```

### BasicAuthç›¸å…³æ–¹æ³•

```go
func (r *Request) BasicAuth() (username, password string, ok bool) {
	auth := r.Header.Get("Authorization")
	if auth == "" {
		return
	}
	return parseBasicAuth(auth)
}

func parseBasicAuth(auth string) (username, password string, ok bool) {
	const prefix = "Basic "
	// Case insensitive prefix match. See Issue 22736.
	if len(auth) < len(prefix) || !strings.EqualFold(auth[:len(prefix)], prefix) {
		return
	}
	c, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
	if err != nil {
		return
	}
	cs := string(c)
	s := strings.IndexByte(cs, ':')
	if s < 0 {
		return
	}
	return cs[:s], cs[s+1:], true
}

// parseBasicAuth parses an HTTP Basic Authentication string.
// "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==" returns ("Aladdin", "open sesame", true).
```

