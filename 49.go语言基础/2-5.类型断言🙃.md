# ç±»å‹æ–­è¨€ğŸ™ƒ

## Type AssertionğŸ˜‹

> Type assertion(æ–­è¨€)æ˜¯ç”¨äº interface value çš„ä¸€ç§æ“ä½œï¼Œè¯­æ³•æ˜¯ x.(T)ï¼Œx æ˜¯ interface type çš„è¡¨è¾¾å¼ï¼Œè€Œ T æ˜¯ assertd typeï¼Œè¢«æ–­è¨€çš„ç±»å‹ã€‚

æ–­è¨€çš„ä½¿ç”¨ä¸»è¦æœ‰ä¸¤ç§æƒ…æ™¯:

**å¦‚æœ asserted type æ˜¯ä¸€ä¸ª concrete typeï¼Œä¸€ä¸ªå®ä¾‹ç±» typeï¼Œæ–­è¨€ä¼šæ£€æŸ¥ x çš„ dynamic type æ˜¯å¦å’Œ T ç›¸åŒï¼Œå¦‚æœç›¸åŒï¼Œæ–­è¨€çš„ç»“æœæ˜¯ x çš„ dynamic value**ï¼Œå½“ç„¶ dynamic value çš„ type å°±æ˜¯ T äº†ã€‚æ¢å¥è¯è¯´ï¼Œå¯¹ concrete type çš„æ–­è¨€å®é™…ä¸Šæ˜¯è·å– x çš„ dynamic valueã€‚

**å¦‚æœ asserted type æ˜¯ä¸€ä¸ª interface typeï¼Œæ–­è¨€çš„ç›®çš„æ˜¯ä¸ºäº†æ£€æµ‹ x çš„ dynamic type æ˜¯å¦æ»¡è¶³ Tï¼Œå¦‚æœæ»¡è¶³ï¼Œæ–­è¨€çš„ç»“æœæ˜¯æ»¡è¶³ T çš„è¡¨è¾¾å¼ï¼Œä½†æ˜¯å…¶ dynamic type å’Œ dynamic value ä¸ x æ˜¯ä¸€æ ·çš„**ã€‚æ¢å¥è¯è¯´ï¼Œå¯¹ interface type çš„æ–­è¨€å®é™…ä¸Šæ”¹å˜äº† x çš„ typeï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªæ›´å¤§ method set çš„ interface typeï¼Œä½†æ˜¯ä¿ç•™åŸæ¥çš„ dynamic type å’Œ dynamic valueã€‚

**case 1**

```go
package main

import (
    "fmt"
    "io"
    "os"
)

func main() {

    var w io.Writer
    w = os.Stdout
    w.Write([]byte("hello Go!"))
    fmt.Printf("%T\n", w)
    fw := w.(*os.File)
    fmt.Printf("%T\n", fw)
}
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œw æ˜¯ä¸€ä¸ªæœ‰ `Write` method çš„ interface expressionï¼Œå…¶ dynamic value æ˜¯ os.Stdoutï¼Œæ–­è¨€ `w.(*os.File)` é’ˆå¯¹ concrete type `*os.File` è¿›è¡Œçš„ï¼Œé‚£ä¹ˆ f å°±æ˜¯ w çš„ dynamic value `os.Stdout`ã€‚

**case 2**

```go
package main

import (
    "fmt"
    "io"
    "os"
)

func main() {

    var w io.Writer
    w = os.Stdout
    w.Write([]byte("hello Go!"))
    fmt.Printf("%T\n", w)
    rw := w.(io.ReadWriter)
    fmt.Printf("%T\n", rw)
}
```

ç±»ä¼¼ case 1, æ–­è¨€ `w.(io.ReadWriter)` é’ˆå¯¹ interface type `io.ReadWriter` è¿›è¡Œï¼Œé‚£ä¹ˆ rw æ˜¯ä¸€ä¸ª dynamic value ä¸º `*os.File` çš„ interface valueã€‚

ä¸è®ºæ˜¯é’ˆå¯¹ concrete type è¿˜æ˜¯ Interface type å¦‚æœ assert expression æ˜¯ nil assert éƒ½ä¼šå¤±è´¥ã€‚

```go
var w io.Writer
fw := w.(*os.File) 
//failrw := w.(io.ReadWriter) //fail
```

é€šå¸¸æˆ‘ä»¬ä»…ä»…åªæ˜¯æƒ³çŸ¥é“ dynamic value æ˜¯å“ªç§ concrete type ï¼Œå¯ä»¥å€ŸåŠ© ok è¡¨è¾¾å¼ã€‚

```go
var w io.Writer = os.Stdout
f, ok := w.(*os.File) 
// success: ok, f == os.Stdoutb, ok := w.(*bytes.Buffer) 
// failure: !ok, b == nil
```

åœ¨ ok è¡¨è¾¾å¼ä¸­ nil ä¸ä¼šå¯¼è‡´ assertion å¤±è´¥ï¼Œå¦‚æœ assertion æˆåŠŸ ok æ˜¯ true å¦åˆ™æ˜¯ falseï¼Œå¦ä¸€ä¸ªå˜é‡åœ¨ assertion å¤±è´¥æ—¶æ˜¯ asserted type çš„ zero valueã€‚

OK è¡¨è¾¾å¼ç»å¸¸ç”¨åœ¨ if è¯­å¥ä¸­ï¼š

```go
if f, ok := w.(*os.File); ok {// ...use f...}
```



## Type SwitchesğŸ·

Interface ä¸€èˆ¬è¢«ç”¨åœ¨è¿™ä¸¤ç§åœºåˆï¼Œä¸€ç§æ˜¯åƒ io.Reader, io.Writer é‚£æ ·ï¼Œä¸€ä¸ª interface çš„ method çœŸæ­£å«ä¹‰æ˜¯è¡¨è¾¾äº†å®ç°è¿™ä¸ª interface çš„ä¸åŒ concrete type çš„ç›¸ä¼¼æ€§ï¼Œæ„å‘³ç€è¿™é‡Œå……åˆ†å‘æŒ¥çš„æ˜¯ interface method çš„è¡¨ç°åŠ›ã€‚é‡ç‚¹åœ¨ methodï¼Œè€Œä¸æ˜¯ concrete typeã€‚

ä¸€ç§æ˜¯åˆ©ç”¨ interface å¯ä»¥å­˜å‚¨ä¸åŒ concrete type çš„èƒ½åŠ›ï¼Œåœ¨å¿…è¦çš„æ—¶å€™æ ¹æ®ä¸åŒçš„ concrete type åšä¸åŒçš„å¤„ç†ï¼Œè¿™æ ·çš„ç”¨æ³•å°±æ˜¯åˆ©ç”¨ interface çš„ assertion æ¥åˆ¤æ–­ dynamic type çš„ç±»å‹æ¥åšå‡ºå…·ä½“çš„åˆ¤æ–­ã€‚é‡ç‚¹åœ¨ concrete typeï¼Œè€Œä¸æ˜¯ methodã€‚

**Type switch å°±æ˜¯åˆ©ç”¨ interface å­˜å‚¨ä¸åŒ concrete type çš„èƒ½åŠ›æ¥å®ç°çš„ assertion**ã€‚

```go
switch x.(type) {
    case nil:
case int, uint:
case bool:
case string:
default:
}
```



è¿™ç§ç±»å‹çš„è¯­å¥å« type switchï¼Œå…¶ä¸­ x æ˜¯ interface expressionï¼Œasserted type æ˜¯ type å­—é¢é‡ï¼Œæ¯ä¸ª case è¯­å¥å¯ä»¥æœ‰ä¸€ç§æˆ–å¤šç§ typesï¼Œnil case åŒ¹é…çš„æ˜¯ x == nil çš„æƒ…å†µï¼Œdefault case åŒ¹é…çš„æ˜¯æ²¡æœ‰ç±»å‹åŒ¹é…çš„æƒ…å†µã€‚

æœ‰æ—¶å€™åœ¨ type switch ä¸­æˆ‘ä»¬éœ€è¦ä½¿ç”¨ dynamic valueï¼Œè¿™å°±éœ€è¦ type assertion å¯ä»¥æå– interface çš„ dynamic valueï¼ŒåŒæ ·æœ‰è¿™æ ·çš„è¯­æ³•å¯ä»¥æ”¯æŒè¿™ä¸€æ“ä½œ `switch x := x.(type){}`

```go
package main

import (
    "fmt"
)

func main() {
    var x1 interface{}
    var x2 int
    var x3 string
    var x4 bool

    fmt.Println(sqlQuote(x1))
    fmt.Println(sqlQuote(x2))
    fmt.Println(sqlQuote(x3))
    fmt.Println(sqlQuote(x4))
}

func sqlQuote(x interface{}) string {
    switch x := x.(type) {
    case nil:
        return "null"
    case int, uint:
        return fmt.Sprintf("%d", x)
    case bool:
        if x {
            return "true"
        }

        return "false"
    case string:
        return "string"
    default:
        panic("no match case")
    }
}
```

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­è¢«æå–çš„ value èµ‹å€¼ç»™ xï¼Œè¿™åœ¨ switch block ä¸­ä¼šé®è”½æ–­è¨€è¡¨è¾¾å¼ xï¼Œä½†æ˜¯ä¸ä¼šå½±å“ x åœ¨ function ä¸­çš„ä½¿ç”¨ï¼Œå› ä¸º switch å’Œ for ä¸€æ ·ä¹Ÿæ˜¯ block scopeã€‚