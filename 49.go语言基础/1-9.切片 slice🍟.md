# 切片 slice🍟

> 切片，数组切片是底层array的view，可以理解成对数组地址的映射（引用传递）可以解决函数问题。

![1574687181174](F:\我的笔记\image\1574687181174.png)



### 声明切片🧀

切片符合左开右闭原则，左边不传参的时候默认是0，右边不传参默认到最后，两边都不取就是整个数组。

```go
package main
import "fmt"

func main() {
	arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	fmt.Println(arr[2:6]) //半开半闭原则
	fmt.Println(arr[:6])  //默认左边是0的半开半闭原则
	fmt.Println(arr[2:])
	fmt.Println(arr[:])
}
//[2 3 4 5]
//[0 1 2 3 4 5]
//[2 3 4 5 6 7 8 9]
//[0 1 2 3 4 5 6 7 8 9]
```



### 使用切片代替指针🥠

```go
package main

import "fmt"

func changEle(arr []int) {
	//使用数组切片代替指针
	arr[0] = 1000
}

func main() {
	arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	changEle(arr[2:6])
	fmt.Println("新数组1", arr)
	changEle(arr[:])
	fmt.Println("新数组2", arr)
}

//新数组1 [0 1 1000 3 4 5 6 7 8 9]
//新数组2 [1000 1 1000 3 4 5 6 7 8 9]
```



### 多次切片Reslice🍨

![1574687980940](F:\我的笔记\image\1574687980940.png)

```go
package main

import "fmt"

func main() {
	arrs := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
	s1 := arrs[2:5]
	fmt.Println(s1, "len:", len(s1), "cap", cap(s1))
	s2 := s1[2:6]
	fmt.Println(s2, "len:", len(s2), "cap", cap(s2))
	s3 := s2[1:4]
	fmt.Println(s3, "len:", len(s3), "cap", cap(s3))
}
//[2 3 4] len: 3 cap 6
//[4 5 6 7] len: 4 cap 4
//[5 6 7] len: 3 cap 3
```



### 切片原则🎢

![1574688262797](F:\我的笔记\image\1574688262797.png)



![1574688311151](F:\我的笔记\image\1574688311151.png)





### 添加append🧥

> 当我们的cap大于len时直接填进去（会改变底层数组的值），如果底层数组没有被使用就会被垃圾回收掉，如果len>cap就会申请二倍的长度。

```go
package main

import "fmt"

func main() {
	s4 := append(s1, 10)
	fmt.Println(s4)
	fmt.Println(s1, "\tlen:", len(s1), "cap", cap(s1))
	fmt.Println(s4, "\tlen:", len(s4), "cap", cap(s4)))
	fmt.Println(s1[0:6])
	fmt.Println(s4[0:6])
}

//[2 3 4] 	len: 3 cap 6
//[2 3 4 10] 	len: 4 cap 6
```



### 切片的数据结构🚲

> 切片的本质就是一个框框住了一片连续的内存空间，切片属于引用类型，是链式的。

![1575261660422](F:\我的笔记\image\1575261660422.png)

![1575261735632](F:\我的笔记\image\1575261735632.png)

### 切片不是纯引用类型🍪

我们以为切片作为数组的参数是引用类型，不会形成拷贝，但是实际上它其实是底层数组的一个视图，所以说对于切片数组值修改的操作是可以的，但是一旦要更改切片的指针那是不行的，是不会对实际的切片数组造成影响的。

```go
func unshift(arr []int){
	arr = arr[1:]
	fmt.Print(arr)//[2 3]
}

func main() {
	d := []int{1,2,3}
	unshift(d)
	printSlice(d)//[1 2 3]
}
```

