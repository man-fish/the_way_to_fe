# åå°„ â€” ç¨‹åºè‡ªçŸ¥ğŸ’¾

## å˜é‡çš„å†…åœ¨æœºåˆ¶ğŸ˜¼

Goè¯­è¨€ä¸­çš„å˜é‡æ˜¯åˆ†ä¸ºä¸¤éƒ¨åˆ†çš„:

- ç±»å‹ä¿¡æ¯ï¼šé¢„å…ˆå®šä¹‰å¥½çš„å…ƒä¿¡æ¯ã€‚
- å€¼ä¿¡æ¯ï¼šç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­å¯åŠ¨æ€å˜åŒ–çš„ã€‚

## åå°„ä»‹ç»ğŸš¿

åå°„æ˜¯æŒ‡åœ¨ç¨‹åºè¿è¡ŒæœŸå¯¹ç¨‹åºæœ¬èº«è¿›è¡Œè®¿é—®å’Œä¿®æ”¹çš„èƒ½åŠ›ã€‚ç¨‹åºåœ¨ç¼–è¯‘æ—¶ï¼Œå˜é‡è¢«è½¬æ¢ä¸ºå†…å­˜åœ°å€ï¼Œå˜é‡åä¸ä¼šè¢«ç¼–è¯‘å™¨å†™å…¥åˆ°å¯æ‰§è¡Œéƒ¨åˆ†ã€‚åœ¨è¿è¡Œç¨‹åºæ—¶ï¼Œç¨‹åºæ— æ³•è·å–è‡ªèº«çš„ä¿¡æ¯ã€‚

æ”¯æŒåå°„çš„è¯­è¨€å¯ä»¥åœ¨ç¨‹åºç¼–è¯‘æœŸå°†å˜é‡çš„åå°„ä¿¡æ¯ï¼Œå¦‚å­—æ®µåç§°ã€ç±»å‹ä¿¡æ¯ã€ç»“æ„ä½“ä¿¡æ¯ç­‰æ•´åˆåˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå¹¶ç»™ç¨‹åºæä¾›æ¥å£è®¿é—®åå°„ä¿¡æ¯ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ç¨‹åºè¿è¡ŒæœŸè·å–ç±»å‹çš„åå°„ä¿¡æ¯ï¼Œå¹¶ä¸”æœ‰èƒ½åŠ›ä¿®æ”¹å®ƒä»¬ã€‚Goç¨‹åºåœ¨è¿è¡ŒæœŸä½¿ç”¨reflectåŒ…è®¿é—®ç¨‹åºçš„åå°„ä¿¡æ¯ã€‚  å¹¶ä¸”reflectåŒ…æä¾›äº†reflect.TypeOfå’Œreflect.ValueOfä¸¤ä¸ªå‡½æ•°æ¥è·å–ä»»æ„å¯¹è±¡çš„Valueå’ŒTypeã€‚

## reflectåŒ…ğŸŸ

åœ¨Goè¯­è¨€çš„åå°„æœºåˆ¶ä¸­ï¼Œä»»ä½•æ¥å£å€¼éƒ½ç”±æ˜¯`ä¸€ä¸ªå…·ä½“ç±»å‹`å’Œ`å…·ä½“ç±»å‹çš„å€¼`ä¸¤éƒ¨åˆ†ç»„æˆçš„(æˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡æ¥å£çš„åšå®¢ä¸­æœ‰ä»‹ç»ç›¸å…³æ¦‚å¿µ)ã€‚ åœ¨Goè¯­è¨€ä¸­åå°„çš„ç›¸å…³åŠŸèƒ½ç”±å†…ç½®çš„reflectåŒ…æä¾›ï¼Œä»»æ„æ¥å£å€¼åœ¨åå°„ä¸­éƒ½å¯ä»¥ç†è§£ä¸ºç”±`reflect.Type`å’Œ`reflect.Value`ä¸¤éƒ¨åˆ†ç»„æˆï¼Œå¹¶ä¸”reflectåŒ…æä¾›äº†`reflect.TypeOf`å’Œ`reflect.ValueOf`ä¸¤ä¸ªå‡½æ•°æ¥è·å–ä»»æ„å¯¹è±¡çš„Valueå’ŒTypeã€‚

## TypeOfğŸ‘™

åœ¨Goè¯­è¨€ä¸­ï¼Œä½¿ç”¨`reflect.TypeOf()`å‡½æ•°å¯ä»¥è·å¾—ä»»æ„å€¼çš„ç±»å‹å¯¹è±¡`ï¼ˆreflect.Typeï¼‰`ï¼Œç¨‹åºé€šè¿‡ç±»å‹å¯¹è±¡å¯ä»¥è®¿é—®ä»»æ„å€¼çš„ç±»å‹ä¿¡æ¯ï¼Œè¿™é‡Œ`Typeof`è¿”å›çš„æ˜¯å…ƒç±»å‹ä¿¡æ¯ã€‚

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var a rune
	fmt.Println(reflect.TypeOf(a))		//int32
}
```

### Name( )å’Œkind( )

åœ¨åå°„ä¸­å…³äºç±»å‹è¿˜åˆ’åˆ†ä¸ºä¸¤ç§ï¼š`ç±»å‹ï¼ˆTypeï¼‰`å’Œ`ç§ç±»ï¼ˆKindï¼‰`ã€‚å› ä¸ºåœ¨Goè¯­è¨€ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨typeå…³é”®å­—æ„é€ å¾ˆå¤šè‡ªå®šä¹‰ç±»å‹ï¼Œè€Œ`ç§ç±»ï¼ˆKindï¼‰`å°±æ˜¯æŒ‡åº•å±‚çš„ç±»å‹ï¼Œä½†åœ¨åå°„ä¸­ï¼Œå½“éœ€è¦åŒºåˆ†æŒ‡é’ˆã€ç»“æ„ä½“ç­‰å¤§å“ç§çš„ç±»å‹æ—¶ï¼Œå°±ä¼šç”¨åˆ°`ç§ç±»ï¼ˆKindï¼‰`ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªæŒ‡é’ˆç±»å‹å’Œä¸¤ä¸ªç»“æ„ä½“ç±»å‹ï¼Œé€šè¿‡åå°„æŸ¥çœ‹å®ƒä»¬çš„ç±»å‹å’Œç§ç±»ã€‚

```go
package main

import (
	"fmt"
	"reflect"
)

func reflectType(x interface{}){
	t := reflect.TypeOf(x)
	fmt.Printf("type %v, prototype %v \n",t.Name(),t.Kind())
}

type myInt int64

type person struct {
	name string
}

func main() {
	var a rune			//ç±»å‹åˆ«å
	var b myInt			//è‡ªå®šä¹‰ç±»å‹
	var c *float32		//æŒ‡é’ˆ
	var d person		//å…¶å®ä¹Ÿç®—æ˜¯ç±»å‹åˆ«åï¼Œä½†æ˜¯ç»“æ„ä½“
	var e chan int		//ç®¡é“
	var f []int			//åˆ‡ç‰‡
	var g [5]int		//æ•°ç»„

	reflectType(a)		//type int32	, prototype int32
	reflectType(b)		//type myInt	, prototype int64
	reflectType(c)		//type 			, prototype ptr
	reflectType(d)		//type person	, prototype struct
	reflectType(e)		//type 			, prototype chan
	reflectType(f)		//type 			, prototype slice
	reflectType(g)		//type			, prototype array
}
```

Goè¯­è¨€çš„åå°„ä¸­åƒæ•°ç»„ã€åˆ‡ç‰‡ã€Mapã€æŒ‡é’ˆç­‰ç±»å‹çš„å˜é‡ï¼Œå®ƒä»¬çš„`.Name()`éƒ½æ˜¯è¿”å›`ç©º`ã€‚

åœ¨`reflect`åŒ…ä¸­å®šä¹‰çš„Kindç±»å‹å¦‚ä¸‹ï¼š

```go
type Kind uint
const (
    Invalid Kind = iota  // éæ³•ç±»å‹
    Bool                 // å¸ƒå°”å‹
    Int                  // æœ‰ç¬¦å·æ•´å‹
    Int8                 // æœ‰ç¬¦å·8ä½æ•´å‹
    Int16                // æœ‰ç¬¦å·16ä½æ•´å‹
    Int32                // æœ‰ç¬¦å·32ä½æ•´å‹
    Int64                // æœ‰ç¬¦å·64ä½æ•´å‹
    Uint                 // æ— ç¬¦å·æ•´å‹
    Uint8                // æ— ç¬¦å·8ä½æ•´å‹
    Uint16               // æ— ç¬¦å·16ä½æ•´å‹
    Uint32               // æ— ç¬¦å·32ä½æ•´å‹
    Uint64               // æ— ç¬¦å·64ä½æ•´å‹
    Uintptr              // æŒ‡é’ˆ
    Float32              // å•ç²¾åº¦æµ®ç‚¹æ•°
    Float64              // åŒç²¾åº¦æµ®ç‚¹æ•°
    Complex64            // 64ä½å¤æ•°ç±»å‹
    Complex128           // 128ä½å¤æ•°ç±»å‹
    Array                // æ•°ç»„
    Chan                 // é€šé“
    Func                 // å‡½æ•°
    Interface            // æ¥å£
    Map                  // æ˜ å°„
    Ptr                  // æŒ‡é’ˆ
    Slice                // åˆ‡ç‰‡
    String               // å­—ç¬¦ä¸²
    Struct               // ç»“æ„ä½“
    UnsafePointer        // åº•å±‚æŒ‡é’ˆ
)
```

## ValueOfğŸ¨

`reflect.ValueOf()`è¿”å›çš„æ˜¯`reflect.Value`ç±»å‹ï¼Œå…¶ä¸­åŒ…å«äº†åŸå§‹å€¼çš„å€¼ä¿¡æ¯ã€‚`reflect.Value`ä¸åŸå§‹å€¼ä¹‹é—´å¯ä»¥äº’ç›¸è½¬æ¢ï¼Œå½“ç„¶å¹¶æ²¡æœ‰ä»€ä¹ˆåµç”¨ã€‚

`reflect.Value`ç±»å‹æä¾›çš„è·å–åŸå§‹å€¼çš„æ–¹æ³•å¦‚ä¸‹ï¼š

|           æ–¹æ³•            |                             è¯´æ˜                             |
| :-----------------------: | :----------------------------------------------------------: |
| **Interface() interface** | å°†å€¼ä»¥ interface{} ç±»å‹è¿”å›ï¼Œå¯ä»¥é€šè¿‡ç±»å‹æ–­è¨€è½¬æ¢ä¸ºæŒ‡å®šç±»å‹  |
|      **Int() int64**      |     å°†å€¼ä»¥ int ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æœ‰ç¬¦å·æ•´å‹å‡å¯ä»¥æ­¤æ–¹å¼è¿”å›      |
|     **Uint() uint64**     |     å°†å€¼ä»¥ uint ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æ— ç¬¦å·æ•´å‹å‡å¯ä»¥æ­¤æ–¹å¼è¿”å›     |
|    **Float() float64**    | å°†å€¼ä»¥åŒç²¾åº¦ï¼ˆfloat64ï¼‰ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æµ®ç‚¹æ•°ï¼ˆfloat32ã€float64ï¼‰å‡å¯ä»¥æ­¤æ–¹å¼è¿”å› |
|      **Bool() bool**      |                     å°†å€¼ä»¥ bool ç±»å‹è¿”å›                     |
|    **Bytes() []bytes**    |               å°†å€¼ä»¥å­—èŠ‚æ•°ç»„ []bytes ç±»å‹è¿”å›                |
|    **String() string**    |                     å°†å€¼ä»¥å­—ç¬¦ä¸²ç±»å‹è¿”å›                     |

### é€šè¿‡åå°„è·å–å€¼

```go
func reflectValue(x interface{}) {
	v := reflect.ValueOf(x)
	k := v.Kind()
	switch k {
	case reflect.Int64:
		// v.Int()ä»åå°„ä¸­è·å–æ•´å‹çš„åŸå§‹å€¼ï¼Œç„¶åé€šè¿‡int64()å¼ºåˆ¶ç±»å‹è½¬æ¢
		fmt.Printf("type is int64, value is %d\n", int64(v.Int()))
	case reflect.Float32:
		// v.Float()ä»åå°„ä¸­è·å–æµ®ç‚¹å‹çš„åŸå§‹å€¼ï¼Œç„¶åé€šè¿‡float32()å¼ºåˆ¶ç±»å‹è½¬æ¢
		fmt.Printf("type is float32, value is %f\n", float32(v.Float()))
	case reflect.Float64:
		// v.Float()ä»åå°„ä¸­è·å–æµ®ç‚¹å‹çš„åŸå§‹å€¼ï¼Œç„¶åé€šè¿‡float64()å¼ºåˆ¶ç±»å‹è½¬æ¢
		fmt.Printf("type is float64, value is %f\n", float64(v.Float()))
	}
}
func main() {
	var a float32 = 3.14
	var b int64 = 100
	reflectValue(a) // type is float32, value is 3.140000
	reflectValue(b) // type is int64, value is 100
	// å°†intç±»å‹çš„åŸå§‹å€¼è½¬æ¢ä¸ºreflect.Valueç±»å‹
	c := reflect.ValueOf(10)
	fmt.Printf("type c :%T\n", c) // type c :reflect.Value
}
```

### é€šè¿‡åå°„è®¾ç½®å˜é‡çš„å€¼

`reflect.Value`ç±»å‹æä¾›çš„ä¿®æ”¹åŸå§‹å€¼çš„æ–¹æ³•å¦‚ä¸‹ï¼š

|          æ–¹æ³•          |                             è¯´æ˜                             |
| :--------------------: | :----------------------------------------------------------: |
|   **SetInt() int64**   |        æ›´æ”¹å€¼ä¸º int ç±»å‹ï¼Œæ‰€æœ‰æœ‰ç¬¦å·æ•´å‹å‡å¯ä»¥æ­¤æ–¹å¼         |
|   **Uint() uint64**    |        æ›´æ”¹å€¼ä¸º uint ç±»å‹ï¼Œæ‰€æœ‰æ— ç¬¦å·æ•´å‹å‡å¯ä»¥æ­¤æ–¹å¼        |
| **SetFloat() float64** | å°†å€¼ä»¥åŒç²¾åº¦ï¼ˆfloat64ï¼‰ç±»å‹è¿”å›ï¼Œæ‰€æœ‰æµ®ç‚¹æ•°ï¼ˆfloat32ã€float64ï¼‰å‡å¯ä»¥æ­¤æ–¹å¼è¿”å› |
|   **SetBool() bool**   |                       æ›´æ”¹å€¼ä¸ºå¸ƒå°”ç±»å‹                       |
| **SetBytes() []bytes** |                        æ›´æ”¹å€¼ä¸ºå­—èŠ‚å‹                        |
| **SetString() string** |                        æ›´æ”¹å€¼ä¸ºå­—ç¬¦ä¸²                        |

æƒ³è¦åœ¨å‡½æ•°ä¸­é€šè¿‡åå°„ä¿®æ”¹å˜é‡çš„å€¼ï¼Œéœ€è¦æ³¨æ„å‡½æ•°å‚æ•°ä¼ é€’çš„æ˜¯å€¼æ‹·è´ï¼Œå¿…é¡»ä¼ é€’å˜é‡åœ°å€æ‰èƒ½ä¿®æ”¹å˜é‡å€¼ã€‚è€Œåå°„ä¸­ä½¿ç”¨ä¸“æœ‰çš„`Elem()`æ–¹æ³•æ¥è·å–æŒ‡é’ˆå¯¹åº”çš„å€¼ã€‚

```go
package main

import (
	"fmt"
	"reflect"
)

func reflectSetValue1(x interface{}) {
	v := reflect.ValueOf(x)
	if v.Kind() == reflect.Int64 {
		v.SetInt(200) //ä¿®æ”¹çš„æ˜¯å‰¯æœ¬ï¼ŒreflectåŒ…ä¼šå¼•å‘panic
	}
}
func reflectSetValue2(x interface{}) {
	v := reflect.ValueOf(x)
	// åå°„ä¸­ä½¿ç”¨ Elem()æ–¹æ³•è·å–æŒ‡é’ˆå¯¹åº”çš„å€¼
	if v.Elem().Kind() == reflect.Int64 {
		v.Elem().SetInt(200)
	}
}
func main() {
	var a int64 = 100
	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value
	reflectSetValue2(&a)
    var p = new(float32)
	reflectSetValue(p)
	fmt.Println(a)
}
```

### isNil()å’ŒisValid()

#### isNil()

```go
func (v Value) IsNil() bool
```

`IsNil()`æŠ¥å‘ŠvæŒæœ‰çš„å€¼æ˜¯å¦ä¸ºnilã€‚væŒæœ‰çš„å€¼çš„åˆ†ç±»å¿…é¡»æ˜¯é€šé“ã€å‡½æ•°ã€æ¥å£ã€æ˜ å°„ã€æŒ‡é’ˆã€åˆ‡ç‰‡ä¹‹ä¸€ï¼›å¦åˆ™IsNilå‡½æ•°ä¼šå¯¼è‡´panicã€‚

#### isValid()

```go
func (v Value) IsValid() bool
```

`IsValid()`è¿”å›væ˜¯å¦æŒæœ‰ä¸€ä¸ªå€¼ã€‚å¦‚æœvæ˜¯Valueé›¶å€¼ä¼šè¿”å›å‡ï¼Œæ­¤æ—¶vé™¤äº†IsValidã€Stringã€Kindä¹‹å¤–çš„æ–¹æ³•éƒ½ä¼šå¯¼è‡´panicã€‚

#### ä¸¾ä¸ªä¾‹å­

`IsNil()`å¸¸è¢«ç”¨äºåˆ¤æ–­æŒ‡é’ˆæ˜¯å¦ä¸ºç©ºï¼›`IsValid()`å¸¸è¢«ç”¨äºåˆ¤å®šè¿”å›å€¼æ˜¯å¦æœ‰æ•ˆã€‚

```go
func main() {
	// *intç±»å‹ç©ºæŒ‡é’ˆ
	var a *int
	fmt.Println("var a *int IsNil:", reflect.ValueOf(a).IsNil())
	// nilå€¼
	fmt.Println("nil IsValid:", reflect.ValueOf(nil).IsValid())
	// å®ä¾‹åŒ–ä¸€ä¸ªåŒ¿åç»“æ„ä½“
	b := struct{}{}
	// å°è¯•ä»ç»“æ„ä½“ä¸­æŸ¥æ‰¾"abc"å­—æ®µ
	fmt.Println("ä¸å­˜åœ¨çš„ç»“æ„ä½“æˆå‘˜:", reflect.ValueOf(b).FieldByName("abc").IsValid())
	// å°è¯•ä»ç»“æ„ä½“ä¸­æŸ¥æ‰¾"abc"æ–¹æ³•
	fmt.Println("ä¸å­˜åœ¨çš„ç»“æ„ä½“æ–¹æ³•:", reflect.ValueOf(b).MethodByName("abc").IsValid())
	// map
	c := map[string]int{}
	// å°è¯•ä»mapä¸­æŸ¥æ‰¾ä¸€ä¸ªä¸å­˜åœ¨çš„é”®
	fmt.Println("mapä¸­ä¸å­˜åœ¨çš„é”®ï¼š", reflect.ValueOf(c).MapIndex(reflect.ValueOf("å¨œæ‰")).IsValid())
}
```

### é€šè¿‡Type( )ï¼ˆValueç»“æ„ä½“ï¼‰æ‹¿åˆ°å¯¹åº”çš„Typeç»“æ„ä½“

å¯ä»¥è¿™ä¹ˆæ‹¿ä½†æ˜¯ä¸èƒ½åç€æ‹¿ã€‚

```go
func (v Value) Type() Type {}
```

## ç»“æ„ä½“åå°„ğŸ”¬

ä»»æ„å€¼é€šè¿‡`reflect.TypeOf()`è·å¾—åå°„å¯¹è±¡ä¿¡æ¯åï¼Œå¦‚æœå®ƒçš„ç±»å‹æ˜¯ç»“æ„ä½“ï¼Œå¯ä»¥é€šè¿‡åå°„å€¼å¯¹è±¡ï¼ˆ`reflect.Type`ï¼‰çš„`NumField()`å’Œ`Field()`æ–¹æ³•è·å¾—ç»“æ„ä½“æˆå‘˜çš„è¯¦ç»†ä¿¡æ¯ã€‚

`reflect.Type`ä¸­ä¸è·å–ç»“æ„ä½“æˆå‘˜ç›¸å…³çš„çš„æ–¹æ³•å¦‚ä¸‹è¡¨æ‰€ç¤ºã€‚

|                            æ–¹æ³•                             |                             è¯´æ˜                             |
| :---------------------------------------------------------: | :----------------------------------------------------------: |
|                  Field(i int) StructField                   |          æ ¹æ®ç´¢å¼•ï¼Œè¿”å›ç´¢å¼•å¯¹åº”çš„ç»“æ„ä½“å­—æ®µçš„ä¿¡æ¯ã€‚          |
|                       NumField() int                        |                   è¿”å›ç»“æ„ä½“æˆå‘˜å­—æ®µæ•°é‡ã€‚                   |
|        FieldByName(name string) (StructField, bool)         |       æ ¹æ®ç»™å®šå­—ç¬¦ä¸²è¿”å›å­—ç¬¦ä¸²å¯¹åº”çš„ç»“æ„ä½“å­—æ®µçš„ä¿¡æ¯ã€‚       |
|            FieldByIndex(index []int) StructField            | å¤šå±‚æˆå‘˜è®¿é—®æ—¶ï¼Œæ ¹æ® []int æä¾›çš„æ¯ä¸ªç»“æ„ä½“çš„å­—æ®µç´¢å¼•ï¼Œè¿”å›å­—æ®µçš„ä¿¡æ¯ã€‚ |
| FieldByNameFunc(match func(string) bool) (StructField,bool) |              æ ¹æ®ä¼ å…¥çš„åŒ¹é…å‡½æ•°åŒ¹é…éœ€è¦çš„å­—æ®µã€‚              |
|                       NumMethod() int                       |                è¿”å›è¯¥ç±»å‹çš„æ–¹æ³•é›†ä¸­æ–¹æ³•çš„æ•°ç›®                |
|                     Method(int) Method                      |                è¿”å›è¯¥ç±»å‹æ–¹æ³•é›†ä¸­çš„ç¬¬iä¸ªæ–¹æ³•                 |
|             MethodByName(string)(Method, bool)              |              æ ¹æ®æ–¹æ³•åè¿”å›è¯¥ç±»å‹æ–¹æ³•é›†ä¸­çš„æ–¹æ³•              |

### Field() æ–¹æ³•

Typeæˆ–è€…æ˜¯Valueç»“æ„ä½“éƒ½å¯ä»¥ä½¿ç”¨æ–¹æ³•ã€‚

```go
func (v Value) Field(i int) Value {}
```

```go
func (t Type) Field(i int) StructField {}
```

### StructFieldç±»å‹

`StructField`ç±»å‹ç”¨æ¥æè¿°ç»“æ„ä½“ä¸­çš„ä¸€ä¸ªå­—æ®µçš„ä¿¡æ¯ã€‚

`StructField`çš„å®šä¹‰å¦‚ä¸‹ï¼š

```go
type StructField struct { 
    Name    string		// Nameæ˜¯å­—æ®µçš„åå­—
    PkgPath string		// PkgPathæ˜¯éå¯¼å‡ºå­—æ®µçš„åŒ…è·¯å¾„ï¼Œå¯¹å¯¼å‡ºå­—æ®µè¯¥å­—æ®µä¸º""
    Type      Type      // å­—æ®µçš„ç±»å‹
    Tag       StructTag // å­—æ®µçš„æ ‡ç­¾
    Offset    uintptr   // å­—æ®µåœ¨ç»“æ„ä½“ä¸­çš„å­—èŠ‚åç§»é‡
    Index     []int     // ç”¨äºType.FieldByIndexæ—¶çš„ç´¢å¼•åˆ‡ç‰‡
    Anonymous bool      // æ˜¯å¦åŒ¿åå­—æ®µ
}
```

### éå†NumField()

æˆ‘ä»¬å¯ä»¥é€šè¿‡t/vä»»æ„ä¸€ä¸ªè¿”å›çš„NumFieldæ¥è·å–å­—æ®µçš„idï¼Œç„¶åå°±èƒ½é€šè¿‡v/tè·å–æ‰€æœ‰çš„ä¿¡æ¯ã€‚

#### å…ˆtåv

ä¸æ¨èï¼Œè¿˜éœ€è¦é¢å¤–çš„é€šè¿‡ValueOfæ‹¿åˆ°Value

```go
func mapStruct(x interface{}){
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)
	if t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {
		panic("we need a ptr of struct !!")
	}
	for i := 0; i < t.Elem().NumField(); i++ {
		fmt.Printf("value? = %v \n",v.Elem().Field(i).Interface())
        //éå†å€¼
		fmt.Printf("struct name:%v,struct tag:%v,struct type:%v,struct index:%v \n",t.Elem().Field(i).Name,t.Elem().Field(i).Tag,t.Elem().Field(i).Type,t.Elem().Field(i).Index)
        //éå†å­—æ®µ
	}
}
```

#### å…ˆvåt

```go
func mapStruct(x interface{}) (err error) {
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)
	if t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {
		//ç¡®è®¤ä¼ å…¥çš„æ˜¯ç»“æ„ä½“æŒ‡é’ˆç±»å‹
		err = errors.New("Arg x needs to be a ptr of struct")
		return
	}
	for i := 0;i < v.Elem().NumField() ;i++  {
		key := v.Elem().Field(i).Type().Name()
		value := v.Elem().Field(i).Interface()
		fmt.Printf("key: %v,value: %v\n",key,value)
	}
	return
}
```

å½“æˆ‘ä»¬ä½¿ç”¨åå°„å¾—åˆ°ä¸€ä¸ªç»“æ„ä½“æ•°æ®ä¹‹åå¯ä»¥é€šè¿‡ç´¢å¼•ä¾æ¬¡è·å–å…¶å­—æ®µä¿¡æ¯ï¼Œä¹Ÿå¯ä»¥é€šè¿‡å­—æ®µåå»è·å–æŒ‡å®šçš„å­—æ®µä¿¡æ¯ã€‚

#### éå†å­—æ®µ

```go
type student struct {
	Name  string `json:"name"`
	Score int    `json:"score"`
}

func main() {
	stu1 := student{
		Name:  "å°ç‹å­",
		Score: 90,
	}

	t := reflect.TypeOf(stu1)
	fmt.Println(t.Name(), t.Kind()) // student struct
	// é€šè¿‡forå¾ªç¯éå†ç»“æ„ä½“çš„æ‰€æœ‰å­—æ®µä¿¡æ¯
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf("name:%s index:%d type:%v json tag:%v\n", field.Name, field.Index, field.Type, field.Tag.Get("json"))
	}

	// é€šè¿‡å­—æ®µåè·å–æŒ‡å®šç»“æ„ä½“å­—æ®µä¿¡æ¯
	if scoreField, ok := t.FieldByName("Score"); ok {
		fmt.Printf("name:%s index:%d type:%v json tag:%v\n", scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get("json"))
	}
}
```

#### éå†å€¼

```go
package main
import (
    "fmt"
    "reflect"
)
type person struct {
    name string
    age  int
}
func main() {
    v := reflect.ValueOf(person{"steve", 30})
    count := v.NumField()
    for i := 0; i < count; i++ {
        f := v.Field(i)
        switch f.Kind() {
        case reflect.String:
            fmt.Println(f.String())
        case reflect.Int:
            fmt.Println(f.Int())
        }
    }
}
```

```go
package main
 
import (
        "fmt"
        "reflect"
)
 
type User struct  {
        Id int
        Name string
        //addr string
}
 
func main(){
        u := User{Id:1001, Name:"xxx"/*, addr:"xxx"*/}
        t := reflect.TypeOf(u)
        v := reflect.ValueOf(u)
        for k := 0; k < t.NumFiled(); k++ {
                fmt.Printf("%s -- %v \n", t.Filed(k).Name, v.Field(k).Interface())   
        }
}
```

