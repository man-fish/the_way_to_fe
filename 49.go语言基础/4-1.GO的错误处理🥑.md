# GOçš„é”™è¯¯å¤„ç†ğŸ¥‘

Goè¯­è¨€è¿½æ±‚ç®€æ´ä¼˜é›…ï¼Œæ‰€ä»¥ï¼ŒGoè¯­è¨€ä¸æ”¯æŒä¼ ç»Ÿçš„ tryâ€¦catchâ€¦finally è¿™ç§å¼‚å¸¸ï¼Œå› ä¸ºGoè¯­è¨€çš„è®¾è®¡è€…ä»¬è®¤ä¸ºï¼Œå°†å¼‚å¸¸ä¸æ§åˆ¶ç»“æ„æ··åœ¨ä¸€èµ·ä¼šå¾ˆå®¹æ˜“ä½¿å¾—ä»£ç å˜å¾—æ··ä¹±ã€‚å› ä¸ºå¼€å‘è€…å¾ˆå®¹æ˜“æ»¥ç”¨å¼‚å¸¸ï¼Œç”šè‡³ä¸€ä¸ªå°å°çš„é”™è¯¯éƒ½æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚åœ¨Goè¯­è¨€ä¸­ï¼Œä½¿ç”¨å¤šå€¼è¿”å›æ¥è¿”å›é”™è¯¯ã€‚ä¸è¦ç”¨å¼‚å¸¸ä»£æ›¿é”™è¯¯ï¼Œæ›´ä¸è¦ç”¨æ¥æ§åˆ¶æµç¨‹ã€‚åœ¨æä¸ªåˆ«çš„æƒ…å†µä¸‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé‡åˆ°çœŸæ­£çš„å¼‚å¸¸çš„æƒ…å†µä¸‹ï¼ˆæ¯”å¦‚é™¤æ•°ä¸º0äº†ï¼‰ã€‚æ‰ä½¿ç”¨Goä¸­å¼•å…¥çš„Exceptionå¤„ç†ï¼šdefer, panic, recoverã€‚

## panic

```go
func panic(v interface{})
```

panic è‹±æ–‡åŸæ„ï¼šn. ææ…Œï¼ŒæƒŠæ…Œï¼›å¤§ææ…Œ  adj. ææ…Œçš„ï¼›æ²¡æœ‰ç†ç”±çš„  vt. ä½¿ææ…Œ  vi. ååˆ†æƒŠæ…Œ

panic æ˜¯ç”¨æ¥è¡¨ç¤ºéå¸¸ä¸¥é‡çš„ä¸å¯æ¢å¤çš„é”™è¯¯çš„ã€‚åœ¨Goè¯­è¨€ä¸­è¿™æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ªinterface{}ç±»å‹çš„å€¼ï¼ˆä¹Ÿå°±æ˜¯ä»»ä½•å€¼äº†ï¼‰ä½œä¸ºå‚æ•°ã€‚panicçš„ä½œç”¨å°±åƒæˆ‘ä»¬å¹³å¸¸æ¥è§¦çš„å¼‚å¸¸ã€‚ä¸è¿‡Goå¯æ²¡æœ‰tryâ€¦catchï¼Œæ‰€ä»¥ï¼Œpanicä¸€èˆ¬ä¼šå¯¼è‡´ç¨‹åºæŒ‚æ‰ï¼ˆé™¤érecoverï¼‰ã€‚æ‰€ä»¥ï¼ŒGoè¯­è¨€ä¸­çš„å¼‚å¸¸ï¼Œé‚£çœŸçš„æ˜¯å¼‚å¸¸äº†ã€‚ä½ å¯ä»¥è¯•è¯•ï¼Œè°ƒç”¨panicçœ‹çœ‹ï¼Œç¨‹åºç«‹é©¬æŒ‚æ‰ï¼Œç„¶åGoè¿è¡Œæ—¶ä¼šæ‰“å°å‡ºè°ƒç”¨æ ˆã€‚
ä½†æ˜¯ï¼Œå…³é”®çš„ä¸€ç‚¹æ˜¯ï¼Œå³ä½¿å‡½æ•°æ‰§è¡Œçš„æ—¶å€™panicäº†ï¼Œå‡½æ•°ä¸å¾€ä¸‹èµ°äº†ï¼Œè¿è¡Œæ—¶å¹¶ä¸æ˜¯ç«‹åˆ»å‘ä¸Šä¼ é€’panicï¼Œè€Œæ˜¯åˆ°deferé‚£ï¼Œç­‰deferçš„ä¸œè¥¿éƒ½è·‘å®Œäº†ï¼Œpanicå†å‘ä¸Šä¼ é€’ã€‚æ‰€ä»¥è¿™æ—¶å€™ defer æœ‰ç‚¹ç±»ä¼¼ try-catch-finally ä¸­çš„ finallyã€‚panicå°±æ˜¯è¿™ä¹ˆç®€å•ã€‚æŠ›å‡ºä¸ªçœŸæ­£æ„ä¹‰ä¸Šçš„å¼‚å¸¸ã€‚

## recover

```go
func recover() interface{}	//panicä¸­ä¼ é€’çš„ç©ºæ¥å£ç±»å‹ã€‚
```

recover è‹±æ–‡åŸæ„ï¼š vt. æ¢å¤ï¼›å¼¥è¡¥ï¼›é‡æ–°è·å¾—  vi. æ¢å¤ï¼›èƒœè¯‰ï¼›é‡æ–°å¾—çƒ  n. è¿˜åŸè‡³é¢„å¤‡å§¿åŠ¿

ä¸Šé¢è¯´åˆ°ï¼Œpanicçš„å‡½æ•°å¹¶ä¸ä¼šç«‹åˆ»è¿”å›ï¼Œè€Œæ˜¯å…ˆdeferï¼Œå†è¿”å›ã€‚è¿™æ—¶å€™ï¼ˆdeferçš„æ—¶å€™ï¼‰ï¼Œå¦‚æœæœ‰åŠæ³•å°†panicæ•è·åˆ°ï¼Œå¹¶é˜»æ­¢panicä¼ é€’ï¼Œé‚£å°±å¼‚å¸¸çš„å¤„ç†æœºåˆ¶å°±å®Œå–„äº†ã€‚

Goè¯­è¨€æä¾›äº†recoverå†…ç½®å‡½æ•°ï¼Œå‰é¢æåˆ°ï¼Œä¸€æ—¦panicï¼Œé€»è¾‘å°±ä¼šèµ°åˆ°deferé‚£ï¼Œé‚£æˆ‘ä»¬å°±åœ¨deferé‚£ç­‰ç€ï¼Œè°ƒç”¨recoverå‡½æ•°å°†ä¼šæ•è·åˆ°å½“å‰çš„panicï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œè¢«æ•è·åˆ°çš„panicå°±ä¸ä¼šå‘ä¸Šä¼ é€’äº†ï¼Œäºæ˜¯ï¼Œä¸–ç•Œæ¢å¤äº†å’Œå¹³ã€‚ä½ å¯ä»¥å¹²ä½ æƒ³å¹²çš„äº‹æƒ…äº†ã€‚

ä¸è¿‡è¦æ³¨æ„çš„æ˜¯ï¼Œrecoverä¹‹åï¼Œé€»è¾‘å¹¶ä¸ä¼šæ¢å¤åˆ°panicé‚£ä¸ªç‚¹å»ï¼Œå‡½æ•°è¿˜æ˜¯ä¼šåœ¨deferä¹‹åè¿”å›ã€‚

panicæ¥å—ä»»æ„ç±»å‹ï¼Œä¼šè½¬æ¢æˆå­—ç¬¦ä¸²è¾“å‡ºå¹¶ä¸”ä¸­æ–­æ‰§è¡Œã€‚

```go
func main() {
    //æ–¹æ³•ä¸€ï¼š
    //é‡‡ç”¨errorsåŒ…çš„Newæ–¹æ³• è¿”å›ä¸€ä¸ªerrçš„ç±»å‹
    var err error = errors.New("this is a new error")
    //ç”±äºå·²ç»å®ç°äº†erroræ¥å£çš„æ–¹æ³• å› æ­¤å¯ä»¥ç›´æ¥è°ƒç”¨å¯¹åº”çš„æ–¹æ³•
    fmt.Println(err.Error())

    //æ–¹æ³•äºŒï¼š
    //é‡‡ç”¨fmt.Errof å°†stringä¿¡æ¯è½¬åŒ–ä¸ºerrorä¿¡æ¯ å¹¶è¿”å›
    err = fmt.Errorf("%s", "the error test for fmt.Errorf")
    fmt.Println(err.Error())
}
```



# GOçš„é”™è¯¯ç±»å‹

`error`æ¥å£åŒ…å«ä¸€ä¸ªå‡½æ•°è¿”å›ä¸€ä¸ª`string`ç±»å‹ï¼Œé€šå¸¸æˆ‘ä»¬panicæ—¶å°±ä¼šæ‰“å°è¿™ä¸ª`string`ç±»å‹ã€‚

```go
type error interface {
	Error() string
}
```

## errors

`errors`åŒ…ç»™ä½ å®ç°äº†ä¸€ä¸ª`error`æ¥å£ã€‚

```go
// Package errors implements functions to manipulate errors.
package errors

// New returns an error that formats as the given text.
func New(text string) error {
    return &errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

#### ä½¿ç”¨

```go
func main() {
    //é‡‡ç”¨errorsåŒ…çš„Newæ–¹æ³• è¿”å›ä¸€ä¸ªerrçš„ç±»å‹
    var err error = errors.New("this is a new error")
    //ç”±äºå·²ç»å®ç°äº†erroræ¥å£çš„æ–¹æ³• å› æ­¤å¯ä»¥ç›´æ¥è°ƒç”¨å¯¹åº”çš„æ–¹æ³•
    fmt.Println(err.Error())
}
```



## fmt

é‡‡ç”¨`fmt.Errorf`æ–¹æ³•æŠŠ`string`ç±»å‹è½¬åŒ–ä¸º`error`ç±»å‹ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•çš„å†…éƒ¨ï¼Œå…ˆè°ƒç”¨`fmt`åŒ…ä¸­çš„`Sprintf`æ–¹æ³•æŠŠæ ¼å¼åŒ–çš„è¾“å…¥è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œåœ¨ä½¿ç”¨ `errors.New` æ–¹æ³•è¿”å›`error`ç±»å‹ã€‚

```go
func Errorf(format string, a ...interface{}) error {
    p := newPrinter()
    p.wrapErrs = true
    p.doPrintf(format, a)
    s := string(p.buf)
    var err error
    if p.wrappedErr == nil {
        err = errors.New(s)
    } else {
        err = &wrapError{s, p.wrappedErr}
    }
    p.free()
    return err
}
```

#### ä½¿ç”¨

```go
func main() {
    //é‡‡ç”¨fmt.Errof å°†stringä¿¡æ¯è½¬åŒ–ä¸ºerrorä¿¡æ¯ å¹¶è¿”å›
    err = fmt.Errorf("%s", "the error test for fmt.Errorf")
    fmt.Println(err.Error())
}
```



## è‡ªå®šä¹‰é”™è¯¯ç±»å‹

#### æ¥å£

```go
type userError interface {
	error
	Message() string
}
```

#### å®ç°è€…

```go
type userError string

func (e userError) Error() string {
	return e.Message()
}

func (e userError) Message() string {
	return string(e)
}
```



## web å…¨å±€å¤„ç†

#### æ€»å…¥å£

```go
package main

import (
	"fmt"
	"go_learning/src/eorrorhandle/staticfIleserver/filelisten"
	"log"
	"net/http"
	"os"
)

type appHandler func(writer http.ResponseWriter,request *http.Request) error
//å› ä¸ºHandleFuncè¦çš„å‡½æ•°æ²¡æœ‰errorè¿”å›å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬åŒ…è£¹HandleFuncï¼Œè°ƒç”¨çœŸæ­£çš„è·¯ç”±å‡½æ•°å¤„ç†æ‰ä»–å†…éƒ¨çš„errorã€‚

func errWraper(handler appHandler) func(writer http.ResponseWriter,request *http.Request){
	return func(writer http.ResponseWriter, request *http.Request) {
 		defer func() {
 			//é˜²æ­¢å¼•ç”¨ç¨‹åºå†…éƒ¨å‡ºé”™ã€‚
 			if r := recover(); r != nil {
 				log.Printf("Panic:%v",r)
 				http.Error(writer,
 					http.StatusText(http.StatusInternalServerError),
 					http.StatusInternalServerError)
			}
		}()
		err := handler(writer,request)
		//å®é™…ä¸šåŠ¡æ‰§è¡Œè¯­å¥ä½“
		if err != nil {
            //å¤„ç†å®é™…è·¯ç”±å†…éƒ¨æš´éœ²å‡ºæ¥çš„errorï¼Œç±»ä¼¼ä¹‹å‰åšçš„koaæ¡†æ¶çš„é”™è¯¯å°è£…,æˆ‘ä»¬å·²çŸ¥çš„é”™è¯¯ç±»å‹é€šè¿‡å†…ç½®çš„å®šä¹‰ç å¤„ç†è¿”å›ç»™			  å®¢æˆ·ç«¯ï¼Œä¸çŸ¥é“çš„ç±»å‹ç›´æ¥æŠ›å‡º500é”™è¯¯ï¼Œå½“ç„¶å†…ç½®çš„é”™è¯¯ç±»å‹é€šå¸¸éƒ½æ˜¯ä¸å¤Ÿçš„ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå·±å®šä¹‰é”™è¯¯æ¥å£ã€‚
			fmt.Println(fmt.Sprintf("Errot handling Requestï¼š%s"),err.Error())

			if userErr, ok := err.(userError); ok {
                //è°ƒç”¨æˆ‘ä»¬åœ¨è¿™é‡Œè®¾ç½®çš„é¸­å­ç±»å‹ï¼Œæ¥å¤„ç†æˆ‘ä»¬æ‹“å±•çš„é”™è¯¯ç±»å‹ã€‚
				http.Error(writer,
					userErr.Message(),
					http.StatusBadRequest)
				return
			}

			code := http.StatusOK
			switch {
			case os.IsNotExist(err):
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(
				writer,
				http.StatusText(code),
				code,)
		}
	}
}

type userError interface {
    //è°ƒç”¨æˆ‘ä»¬åœ¨è¿™é‡Œè®¾ç½®çš„é¸­å­ç±»å‹ã€‚
	error
	Message() string
}

func main() {
	http.HandleFunc("/",errWraper(filelisten.HandleFileList))
	err := http.ListenAndServe(":8888",nil)
	if err != nil {
		panic (err)
	}
}
```

#### æŸè·¯ç”±

åœ¨å®é™…è·¯ç”±å‡½æ•°å†…éƒ¨æˆ‘ä»¬æœ‰é”™è¯¯å°±æŠ›å‡ºæ¥ï¼ˆä¸€å±‚ä¸€å±‚çš„æŠ›å‡ºæ¥ã€‚ï¼‰

```go
package handler

import (
	"fmt"
	"io/ioutil"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
)

type userError string

func (e userError) Error() string {
	return e.Message()
}

func (e userError) Message() string {
	return string(e)
}


const prefix string = "/static/"

func StaticFileHandler(res http.ResponseWriter,req *http.Request) error {
		if strings.Index(req.URL.Path,prefix) != 0 {
			return userError(fmt.Sprintf("Path %v must start with %v",req.URL.Path,prefix))
		}

		filePath := req.URL.Path
		//è·å–æ‰€å–è·¯å¾„
		appPath, err := os.Executable()
		// è·å¾—ç¨‹åºè·¯å¾„(application)
		wantedFile := filepath.Join(filepath.Dir(appPath),filePath)
		//æ‹¼æ¥ä¸ºæ–‡ä»¶è·¯å¾„
		fmt.Println("user visit \n","->",wantedFile)

		fr, err := os.Open(wantedFile)
		if err != nil {
			return err
		}

		defer fr.Close()
		fileContent, err := ioutil.ReadAll(fr)
		if err != nil {
			return err
		}

		SetContentTypeFromExtension(res,path.Ext(filePath))
		//æ ¹æ®æ–‡ä»¶ç±»å‹è®¾ç½®è¯·æ±‚å¤´ã€‚

		_,err = res.Write(fileContent)
		if err != nil {
			return err
		}
		return nil
}

func SetContentTypeFromExtension(w http.ResponseWriter,extension string){
		mimeType := mime.TypeByExtension(extension)
		if mimeType != "" {
			w.Header().Set("Content-Type",mimeType)
		}
}
```

