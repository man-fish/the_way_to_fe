# bufio â€” ç¼“å­˜IOğŸ˜

![](F:\æˆ‘çš„ç¬”è®°\image\jdiasdjio.png)

bufio åŒ…å®ç°äº†ç¼“å­˜IOã€‚å®ƒåŒ…è£…äº† io.Reader å’Œ io.Writer å¯¹è±¡ï¼Œåˆ›å»ºäº†å¦å¤–çš„Readerå’ŒWriterå¯¹è±¡ï¼Œå®ƒä»¬ä¹Ÿå®ç°äº† io.Reader å’Œ io.Writer æ¥å£ï¼Œä¸è¿‡å®ƒä»¬æ˜¯æœ‰ç¼“å­˜çš„ã€‚è¯¥åŒ…åŒæ—¶ä¸ºæ–‡æœ¬I/Oæä¾›äº†ä¸€äº›ä¾¿åˆ©æ“ä½œï¼Œå¹³æ—¶ä½¿ç”¨æ—¶æˆ‘ä»¬ä¸ç›´æ¥å¯¹æ–‡ä»¶è¿›è¡Œè¯»å†™æ“ä½œï¼Œè€Œæ˜¯é€šè¿‡ç¼“å­˜æ¥è¯»å†™ï¼Œè¿™æ ·é€Ÿåº¦æ›´å¿«ï¼Œæ•ˆç‡æ›´é«˜ã€‚

> [è®°ä½æµç¨‹ï¼š]()
>
> `Reader`ï¼šå°†åº•å±‚çš„`io.Reader`é‡Œçš„æ•°æ®å†™å…¥`bufio.Reader`ä¸­ï¼ˆæ­¤æ—¶è°ƒç”¨`io.Reader.Read`ï¼‰ï¼Œç„¶åå†è¯»å–åˆ°çœŸæ­£æƒ³è¦çš„å­—èŠ‚æ•°ç»„ä¸­ï¼ˆæ­¤æ—¶è°ƒç”¨`bufio.Reader.Read`ï¼‰ã€‚
>
> `Writer`ï¼šå°†è¦å†™å…¥åº•å±‚`io.Writer`çš„æ•°æ®å…ˆå†™å…¥`bufio.Writer`ä¸­ï¼ˆæ­¤æ—¶è°ƒç”¨`bufio.Reader.Writer`ï¼‰ï¼Œç„¶åå†å†™å…¥çœŸæ­£æƒ³è¦çš„åº•å±‚Writerä¸­ï¼ˆæ­¤æ—¶è°ƒç”¨`bufio.Writer.Write`ï¼‰ã€‚

## Writer ç±»å‹å’Œæ–¹æ³•ğŸ‘˜

bufio.Writer ç»“æ„åŒ…è£…äº†ä¸€ä¸ª io.Writer å¯¹è±¡ï¼Œæä¾›ç¼“å­˜åŠŸèƒ½ï¼ŒåŒæ—¶å®ç°äº† io.Writer æ¥å£ã€‚

Writer ç»“æ„æ²¡æœ‰ä»»ä½•å¯¼å‡ºçš„å­—æ®µï¼Œç»“æ„å®šä¹‰å¦‚ä¸‹ï¼š

```go
type Writer struct {
    err error        // å†™è¿‡ç¨‹ä¸­é‡åˆ°çš„é”™è¯¯
    buf []byte       // ç¼“å­˜
    n   int          // å½“å‰ç¼“å­˜ä¸­çš„å­—èŠ‚æ•°
    wr  io.Writer    // åº•å±‚çš„ io.Writer å¯¹è±¡
}
```

### å®ä¾‹åŒ–

bufio åŒ…æä¾›äº†ä¸¤ä¸ªå®ä¾‹åŒ– bufio.Writer å¯¹è±¡çš„å‡½æ•°ï¼šNewWriter å’Œ NewWriterSizeã€‚å…¶ä¸­ï¼ŒNewWriter å‡½æ•°æ˜¯è°ƒç”¨ NewWriterSize å‡½æ•°å®ç°çš„ï¼š

```go
func NewWriter(wr io.Writer) *Writer {
    // é»˜è®¤ç¼“å­˜å¤§å°ï¼šdefaultBufSize=4096
    return NewWriterSize(wr, defaultBufSize)
}
```

æˆ‘ä»¬çœ‹ä¸€ä¸‹ NewWriterSize çš„æºç ï¼š

```go
func NewWriterSize(wr io.Writer, size int) *Writer {
    // å·²ç»æ˜¯ bufio.Writer ç±»å‹ï¼Œä¸”ç¼“å­˜å¤§å°ä¸å°äº sizeï¼Œåˆ™ç›´æ¥è¿”å›
    b, ok := wr.(*Writer)
    if ok && len(b.buf) >= size {
        return b
    }
    if size <= 0 {
        size = defaultBufSize
    }
    return &Writer{
        buf: make([]byte, size),
        wr:  w,
    }
}
```

### Available å’Œ Buffered æ–¹æ³•

> Available æ–¹æ³•è·å–ç¼“å­˜ä¸­è¿˜æœªä½¿ç”¨çš„å­—èŠ‚æ•°ï¼ˆç¼“å­˜å¤§å° - å­—æ®µ n çš„å€¼ï¼‰ï¼›
>
> Buffered æ–¹æ³•è·å–å†™å…¥å½“å‰ç¼“å­˜ä¸­çš„å­—èŠ‚æ•°ï¼ˆå­—æ®µ n çš„å€¼ï¼‰ã€‚

```go
func (b *Writer) Available() int { return len(b.buf) - b.n }
func (b *Writer) Buffered() int { return b.n }
```

### Flush æ–¹æ³•

è¯¥æ–¹æ³•å°†ç¼“å­˜ä¸­çš„æ‰€æœ‰æ•°æ®å†™å…¥åº•å±‚çš„ io.Writer å¯¹è±¡ä¸­ã€‚ä½¿ç”¨ bufio.Writer æ—¶ï¼Œåœ¨æ‰€æœ‰çš„ Write æ“ä½œå®Œæˆä¹‹åï¼Œåº”è¯¥è°ƒç”¨ Flush æ–¹æ³•ä½¿å¾—ç¼“å­˜éƒ½å†™å…¥ io.Writer å¯¹è±¡ä¸­ã€‚

```go
func (b *Writer) Flush() error {
	if b.err != nil {
		return b.err
	}
	if b.n == 0 {
        //æ²¡æœ‰ä»¥ç¼“å­˜å­—æ®µå°±è¿”å›ã€‚
		return nil
	}
	n, err := b.wr.Write(b.buf[0:b.n])
    //å°†ä»¥ç¼“å­˜å­—æ®µå†™å…¥io.write
	if n < b.n && err == nil {
        //æ²¡å†™å…¨ï¼Œå¹¶ä¸”æ²¡æœ‰å‘ç”Ÿé”™è¯¯
		err = io.ErrShortWrite
        //ä¸å®Œå…¨å†™å…¥ã€‚
	}
	if err != nil {
		if n > 0 && n < b.n {
			copy(b.buf[0:b.n-n], b.buf[n:b.n])
		}
		b.n -= n
		b.err = err
		return err
	}
	b.n = 0
	return nil
}
```

### Bufio.Writeræœ¬èº«çš„writeå’ŒWriteStringæ–¹æ³•

æ ¹æ®åº•å±‚io.Writerå®ç°è€…åˆ›å»ºBufio.Writerä¹‹åè¿˜éœ€è¦å¡«å……ç¼“å­˜æ•°æ®ã€‚

```go
func (b *Writer) Write(p []byte) (nn int, err error) {
	for len(p) > b.Available() && b.err == nil {
        //å¦‚æœè¯´æ²¡æœ‰å¯å†™å…¥ç©ºé—´äº†ï¼ˆå¯å†™å…¥ç©ºé—´ä¸è¶³ã€‚ï¼‰
		var n int
		if b.Buffered() == 0 {
			// Large write, empty buffer.
			// Write directly from p to avoid copy.
			n, b.err = b.wr.Write(p)
		} else {
			n = copy(b.buf[b.n:], p)
			b.n += n
			b.Flush()
		}
		nn += n
		p = p[n:]
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], p)
    //å°†æ•°æ®å†™å…¥ç¼“å­˜
	b.n += n
	nn += n
	return nn, nil
}
```

```go
func (b *Writer) WriteString(s string) (int, error) {
	nn := 0
	for len(s) > b.Available() && b.err == nil {
		n := copy(b.buf[b.n:], s)
		b.n += n
		nn += n
		s = s[n:]
		b.Flush()
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], s)
	b.n += n
	nn += n
	return nn, nil
}

```

### å®ä¾‹

```go
func writeItBufio(filename string){
	f,_ := os.Create(filename)
    //æ‰“å¼€æ–‡ä»¶ï¼Œè¿”å›*fileå¯¹è±¡.
	defer f.Close()
	writer := bufio.NewWriter(f)
	defer writer.Flush()
    //å°†ç¼“å­˜ä¸­æ•°æ®å†²å…¥æ–‡ä»¶ï¼ˆè°ƒç”¨äº†fileçš„writeæ–¹æ³•ï¼‰ã€‚
	for i:=0;i<10;i++ {
		fmt.Fprintln(writer,i)
        //å‘ç¼“å­˜ä¸­å†™å…¥æ•°æ®ã€‚
	}
}
```



## Readerç±»å‹å’Œæ–¹æ³•ğŸ‘”

bufio.Readerå¯¹è±¡ï¼Œæä¾›ç¼“å­˜åŠŸèƒ½ï¼ŒåŒæ—¶å®ç°äº† io.Raederæ¥å£ã€‚

Writer ç»“æ„æ²¡æœ‰ä»»ä½•å¯¼å‡ºçš„å­—æ®µï¼Œç»“æ„å®šä¹‰å¦‚ä¸‹ï¼š

```go
type Reader struct {
	buf          []byte
	rd           io.Reader // reader provided by the client
	r, w         int       // buf read and write positions
	err          error
	lastByte     int // last byte read for UnreadByte; -1 means invalid
	lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid
}
```

### å®ä¾‹åŒ–

bufio åŒ…æä¾›äº†ä¸¤ä¸ªå®ä¾‹åŒ– bufio.Readerå¯¹è±¡çš„å‡½æ•°ï¼šNewReaderå’Œ NewReaderSizeã€‚å…¶ä¸­ï¼ŒNewReaderå‡½æ•°æ˜¯è°ƒç”¨ NewReaderSizeå‡½æ•°å®ç°çš„ï¼š

```go
func NewReader(rd io.Reader) *Reader {
	return NewReaderSize(rd, defaultBufSize)
}
```

æˆ‘ä»¬çœ‹ä¸€ä¸‹ NewReaderSizeçš„æºç ï¼š

```go
func NewReaderSize(rd io.Reader, size int) *Reader {
	// Is it already a Reader?
	b, ok := rd.(*Reader)
	if ok && len(b.buf) >= size {
		return b
	}
	if size < minReadBufferSize {
		size = minReadBufferSize
	}
	r := new(Reader)
	r.reset(make([]byte, size), rd)
	return r
}
```

### Size æ–¹æ³•

> Size æ–¹æ³•è·å–å†™å…¥å½“å‰ç¼“å­˜ä¸­çš„å­—èŠ‚æ•°
>

```go
func (b *Reader) Size() int { return len(b.buf) }
```

### Peekæ–¹æ³•

ä»æ–¹æ³•çš„åç§°å¯ä»¥çŒœåˆ°ï¼Œè¯¥æ–¹æ³•åªæ˜¯â€œçª¥æ¢â€ä¸€ä¸‹ Reader ä¸­æ²¡æœ‰è¯»å–çš„ n ä¸ªå­—èŠ‚ã€‚å¥½æ¯”æ ˆæ•°æ®ç»“æ„ä¸­çš„å–æ ˆé¡¶å…ƒç´ ï¼Œä½†ä¸å‡ºæ ˆã€‚

**ç­¾åï¼š**

```go
func (b *Reader) Peek(n int) ([]byte, error)
```

**æºç ï¼š**

```go
func (b *Reader) Peek(n int) ([]byte, error) {
    if n < 0 {
        return nil, ErrNegativeCount
    }

    b.lastByte = -1
    b.lastRuneSize = -1

    for b.w-b.r < n && b.w-b.r < len(b.buf) && b.err == nil {
        b.fill() // b.w-b.r < len(b.buf) => buffer is not full
    }

    if n > len(b.buf) {
        return b.buf[b.r:b.w], ErrBufferFull
    }

    // 0 <= n <= len(b.buf)
    var err error
    if avail := b.w - b.r; avail < n {
        // not enough data in buffer
        n = avail
        err = b.readErr()
        if err == nil {
            err = ErrBufferFull
        }
    }
    return b.buf[b.r : b.r+n], err
}
```

### Bufio.Readeræœ¬èº«çš„Readæ–¹æ³•

æ ¹æ®åº•å±‚io.Readerå®ç°è€…åˆ›å»ºBufio.Readerä¹‹åè¿˜éœ€è¦å¡«å……ç¼“å­˜æ•°æ®ï¼Œè€Œå¡«å……ç¼“å­˜æ•°æ®çš„è¿‡ç¨‹å°±æ˜¯ä»åº•å±‚çš„readeré‡Œé¢è¯»å–æ•°æ®ã€‚

```go
func (b *Reader) Read(p []byte) (n int, err error) {
	n = len(p)
	if n == 0 {
		if b.Buffered() > 0 {
			return 0, nil
		}
		return 0, b.readErr()
	}
	if b.r == b.w {
		if b.err != nil {
			return 0, b.readErr()
		}
		if len(p) >= len(b.buf) {
			// Large read, empty buffer.
			// Read directly into p to avoid copy.
			n, b.err = b.rd.Read(p)
			if n < 0 {
				panic(errNegativeRead)
			}
			if n > 0 {
				b.lastByte = int(p[n-1])
				b.lastRuneSize = -1
			}
			return n, b.readErr()
		}
		// One read.
		// Do not use b.fill, which will loop.
		b.r = 0
		b.w = 0
		n, b.err = b.rd.Read(b.buf)
		if n < 0 {
			panic(errNegativeRead)
		}
		if n == 0 {
			return 0, b.readErr()
		}
		b.w += n
	}

	// copy as much as we can
	n = copy(p, b.buf[b.r:b.w])
	b.r += n
	b.lastByte = int(b.buf[b.r-1])
	b.lastRuneSize = -1
	return n, nil
}
```

### å®ä¾‹

```go
func readBufio(reader io.Reader) ([]byte,error) {
	br := bufio.NewReader(reader)
	line, err := br.Peek(100)
	fmt.Println(line)
	return line, err
}
```

