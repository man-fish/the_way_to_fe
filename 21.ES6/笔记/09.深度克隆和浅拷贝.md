# 深度克隆和浅拷贝

## 会发生浅拷贝的原因

赋值对象和数组的时候，赋值的都是地址或者说是指针，修改一个另一个就会发生变化。

```js
let obj1 = null
let obj2 = {
    "age":6,
}

obj1 = obj2

obj2.age = 7  (obj1:{age:7})
```

## 浅拷贝

```js
    /**
     * 浅拷贝和深拷贝（深度克隆）
     * 深拷贝：拷贝之后会生成一份新数据不会影响原数据。
     * 浅拷贝：不是拷贝而是引用，修改“拷贝”的数据会影响原数据的值。
     * */
```

### 浅拷贝实例

```javascript
//数组和对象的直接赋值都是浅拷贝。
    let arr4 = [1,2,3]
    let arr3 = arr4
    arr4[0] = 2
    console.log(arr3) //[2,2,3]
    let obj5 = {name:"jack"}
    let obj4 = obj5
    obj5.name = "bob"
    console.log(obj4)
//concat也是浅拷贝（因为修改拷贝数组的内层存入的对象时，元数据也会改变。）
    let arr = [{name:"jack"},1]
    let arr2 = arr.concat()
    arr2[1] = 2
    arr[0].name = "bob"
    console.log(arr)
//浅拷贝（aasign函数），依然只能达到一层的效果。
    let obj1 = {
        name:{name:"wangbo"}
    }
    let obj2 = {
        age:[1]
    }
    let obj3 = Object.assign(obj2,obj1)
    obj1.name.name = "jack"
    obj2.age[0] = "ree"
    console.log(obj3)
```

## 深拷贝

### 方法一：

```js
    //深拷贝（JSON二次转换）
    let trueobj = JSON.parse(JSON.stringify(obj1))
    obj1.name="foo"
    console.log(trueobj)
```

### 方法二：

```javascript
    /**
     *  深度克隆函数
     *  深度克隆是没有api，只能自己写函数。 
     * */
    function deepclone(good){
        let cloner = Object.prototype.toString.call(good) == '[object Object]'?{}:[]
        for(let item in good){
            if(Object.prototype.toString.call(good[item]) == '[object 	    Object]'||Object.prototype.toString.call(good[item]) == '[object Array]'){
                cloner[item] = deepclone(good[item])    
            }else{
                cloner[item] = good[item]
            }
        }
        return cloner
    }
//检测
    let curArr = [{username:"jack",content:[{username:1}]},1]
    let deepObj = deepclone(curArr)
    curArr[0].content[0].username = "bob"
    console.log(deepObj)
```

 