## 简介

**贪心算法**（英语：`greedy algorithm`），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在[旅行推销员问题](https://zh.wikipedia.org/wiki/旅行推销员问题)中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。

**例子**:最小生成树的算法 `(Prim MST、Kruskal MST、Dijkstra's algorithm)`。

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

贪心算法与[动态规划](https://zh.wikipedia.org/wiki/动态规划)的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

**注意**：贪心算法每一步都要选择当前子状态的最优解，所以说一般要对已知量进行排序，所以排序对于贪心算法效率影响极大。



## 贪心选择性

贪心算法并不难在使用而是难在证明上,想要证明一个问题可以使用贪心算法我们可以从两个角度出发:

1. 举反例证明贪心算法是错误的。
2. 反证法:假设贪心算法为A;最优算法为O,发现A能完全代替O,并且不影响求出最优解。

### 最优证明方法：Exchange Argument交换变量证明法

`Exchange Argument`的主要的思想也就是先假设存在一个最优的算法和我们的贪心算法最接近，然后通过交换两个算法里的一个步骤(或元素)，得到一个新的最优的算法，同时这个算法比前一个最优算法更接近于我们的贪心算法，最优只能有一个，从而得到矛盾，证明所谓的最优算法非最优，原命题成立。

#### 步骤：

**Step0**：给出贪心算法`A`的描述

**Step1**：假设`O`是和`A`最相似**(假设`O`和`A`的前`k`个步骤都相同，第`k+1`个开始不同，通常这个临界的元素最重要)**的最优算法

**Step2**： **`[Key]`** 修改算法`O`**(用`Exchange Argument`，交换`A`和`O`中的一个元素)**，得到新的算法`O’`。

**Step3**： 证明`O’` 是**feasible**（可行的）的，也就是`O’`是对的。

**Step4**： 证明`O’`至少和`O`一样，即`O’`也是最优的

**Step5**：得到矛盾，因为`O’` 比`O` 更和`A` 相似，证毕。

https://blog.csdn.net/zhuzhi123zhuzhi/article/details/52751711



## 实例

### Maximum Cardinality Disjoint Interval Problem 最小无交叉时间段集合 

问题描述：给一些时间片段集合`T={（a1，b1）（a2，b2），。。。，（an，bn）}`，找出一个元素**个数最多**的子集`S`，子集中的每个元素的时间片段没有交叉。

#### Greedy Algorithm 贪婪算法

每次都选所有`interval` 中bi最小的那个，把`（ai，bi）`加入`S`，然后把`（ai，bi）`在`T`中删除，同时把T中所有和`（ai，bi）`有交叉的`interval`删除，然后再在`T`中找最小的`bj`，循环上面的操作，直到没有可以在添加的。

#### Exchange Argument交换变量证明

我们的`Greedy Algorithm`记为`A`，假设`A`不是最优的，那么就一定存在一个`O`，`O`是和`A`最相近的一个最优的算法，`最相近是指和O和A的前K-1个选择都相同，第K个是不同的`。**也就是说这个问题的最优解是`n`，而我们这个选择得到的解最多为`n-1`。**

假设对于`A`，`A`第`k`个选择的是`（ai，bi）`；而`O`第`K`个选择的是`（aj，bj）`。从`A`的定义我们可以直到，`bi<=bj`。

现在我们构造一个**O'，`O' = O-（aj，bj）+（ai，bi）`。**这里我们指代为用`A`的`ai,bi`代替`o`的`aj,bj`。

**1）很显然，O'是这个问题的一个解，也就是说O'中的`intervals`没有重叠的。**

因为`O`算法和`A`算法在前`k-1`和选择是是没有去别的，所以在`O'`中，`（ai，bi）`前的`intervals`和A中的一样，所以前一部分没有重叠。在`（ai，bi）`后的`intervals`和`O`中的一样，因为`bi<=bj`，`（ai，bi）`也不会和它相邻的重叠，所以`（ai，bi）`后的`intervals`也没有重叠，所以`O'`中的所有`intervals`都没有重叠。

**2）`O'`是一个最优解，因为他的`intervals`的个数和O一样。**

综上，我们找到了一个最优解`O'`，它由`O`与`A`交换第`k`个变量而来，和`A`具有的共同的`intervals`有K个，这和我们前提假设最多有`k-1`个相矛盾，所以，`A`是最优的。证毕。

#### 代码

```go
func eraseOverLappingIntervalGreedily(intervals []interval) int {
	IntervalBubbleSortByback(intervals)
	//按区间最后位置大小升序排序。
	if len(intervals) == 0 {
		return 0
	}

	pre := 0
	res := 1

	for i := 1; i < len(intervals); i++ {
		if intervals[pre][1] < intervals[i][0] {
			res++
			pre = i
		}
	}

	return res
}
//intervals := []interval{[2]int{3,5},[2]int{3,4},[2]int{1,2}}
```



### Assign Cookies 分发饼干

假设你是一个很棒的父母，并希望给你的孩子一些饼干。但是，你最多应该给每个孩子一个饼干。每个孩子都有一个贪婪指数`g(i)`，这是指一个饼干的最小大小。孩子将满足：每个 `cookie j` 都有一个大小 `s(j)`。如果 `sj >= gi，`我们可以将 `cookie j` j分配给孩子 i，孩子就会很开心。你的目标是求出最多开心孩子的数目。

#### Greedy Algorithm 贪婪算法

每一次都选择最大块`cookie`分发个最贪婪的小朋友。

#### Exchange Argument交换变量证明

我们的`Greedy Algorithm`记为`A`，假设`A`不是最优的，那么就一定存在一个`O`，`O`是和`A`最相近的一个最优的算法，`最相近是指和O和A的前K-1个选择都相同，第K个是不同的`。**也就是说这个问题的最优解是`n`，而我们这个选择得到的解最多为`n-1`。**

假设对于`A`，`A`第`k`个选择的是`cookie i`；而`O`第`K`个选择的是`cookie j`。从`A`的定义我们可以直到，`w[i] > w[j]`。

现在我们构造一个**O'，`O' = O- w[j]+ w[i]`。**

**1）很显然，O'是这个问题的一个解，也就是说O'中的孩子都很满足。**

因为`O`算法和`A`算法在前`k-1`和选择是是没有区别的，而`w[i] > w[j]`所以第`k`个孩子一定被满足。

**2）`O'`是一个最优解，因为`w[i] > w[j]`第k个孩子甚至跟满足。**

综上，我们找到了一个最优解`O'`，它由`O`与`A`交换第`k`个变量而来，和`A`具有的共同的满足孩子数有K个，这和我们前提假设最多有`k-1`个相矛盾，所以，`A`是最优的。证毕。

#### 代码

```go
func feedContentChildren(g []int, s []int) int {
	sort.BubbleSort(g)
	sort.BubbleSort(s)

	var si, gi,res int
	for si < len(s) && gi < len(g) {
		if s[si] >= g[gi] {
			res++
			si++
			gi++
		}else{
			gi++
		}
	}
	return res
}
```

