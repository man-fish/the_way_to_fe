# complete$Work

[react-reconciler/src/ReactFiberScheduler.js]()

```ts
function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;
	//...
 	next = beginWork(current, workInProgress, nextRenderExpirationTime);
	workInProgress.memoizedProps = workInProgress.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    next = completeUnitOfWork(workInProgress);
  }
  return next;
}

function renderRoot(
  root: FiberRoot,
  isYieldy: boolean,
  isExpired: boolean,
): void {
  do {
    try {
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } catch (thrownValue) {
      if (nextUnitOfWork === null) { // è‡´å‘½é”™è¯¯ï¼ŒnextUnitOfWorkå³ä½¿æŠ›å‡ºé”™è¯¯ä¹Ÿä¸åº”è¯¥ == null
        // This is a fatal error.
        didFatal = true;
        onUncaughtError(thrownValue);
      } else {
        const failedUnitOfWork: Fiber = nextUnitOfWork;
        const sourceFiber: Fiber = nextUnitOfWork;
        let returnFiber = sourceFiber.return;
        if (returnFiber === null) { // è‡´å‘½é”™è¯¯
          didFatal = true;
          onUncaughtError(thrownValue);
        } else {
          throwException(
            root,
            returnFiber,
            sourceFiber,
            thrownValue,
            nextRenderExpirationTime,
          );
          nextUnitOfWork = completeUnitOfWork(sourceFiber);
          continue;
        }
      }
    }
    break;
  } while (true);
}
```

å›åˆ°`renderRoot` ï¼Œå½“ `performUnitOfWork`ä¸­ `beginWork` å·²ç»ä¸æ–­æ·±åº¦ä¼˜å…ˆçš„é¡ºåºéå†åˆ°äº†æœ€åä¸€ä¸ª `fiber`ï¼Œç›®å‰ `next`æŒ‡é’ˆæŒ‡å‘çš„æ˜¯è¿™ä¸ªæ£µæ ‘æœ€åº•å±‚çš„ `child`ï¼š

<img src="assets/fiberTree2.png" alt="fiberTree2" style="zoom:80%;" />

åœ¨è¿™é‡Œæˆ‘ä»¬è¦æ‰§è¡Œ `completeUnitOfWork` å‘å…„å¼Ÿæ‹“å±•ï¼Œæˆ–è€…å‘ä¸Šè¿”å›ï¼Œå…·ä½“æ¥çœ‹ä»£ç ï¼Œæœ€å¤–å±‚æ˜¯ä¸€ä¸ª `while(true)`ï¼Œ`returnFiber` æ ‡è®°çˆ¶èŠ‚ç‚¹ï¼Œ`siblingFiber` æ ‡è®°å…„å¼ŸèŠ‚ç‚¹ï¼š

+ `NoIncomplete`è¿™ç§æƒ…å†µè¡¨ç¤ºåœ¨æ›´æ–°çš„è¿‡ç¨‹ä¸­æ²¡æœ‰é”™è¯¯æŠ›å‡ºï¼Œèµ°çš„æ˜¯ `completeWork`è¿›å…¥ `completeUnitOfWork` çš„ å…¥å£ä¹Ÿæ˜¯ä¸Šé¢çš„ç¬¬ä¸€ç§å…¥å£ã€‚
  + è°ƒç”¨ `completeWork` å¤„ç†å½“å‰ `fiber` çš„ä¸€äº›æ›´æ–°ã€‚
  + è°ƒç”¨ `resetChildExpirationTime`ï¼Œå› ä¸º `completeWork` æ˜¯ä»ä¸‹å¾€ä¸Šè¿›è¡Œçš„ï¼Œæ‰€ä»¥æ›´æ–°å·²å®Œæˆè¦é‡ç½® `ChildExpirationTime`ã€‚
  + ä¹‹åæ˜¯å¯¹å‰¯ä½œç”¨ `effect` çš„è®¾ç½®ï¼Œé¦–å…ˆå‰¯ä½œç”¨çš„å¤„ç†æœ€åä¼šä¸€å±‚ä¸€å±‚ä¼ é€’æ‹¼æ¥åˆ° `fiberRoot`çš„ `firstEffect` ä¸Šï¼Œæ‰€ä»¥åœ¨ä»»æ„ä¸€ä¸ª `fiber` ä¸Šé¦–å…ˆä¼šå°†è‡ªå·±çš„ `Effect` é“¾æ¡æ‹¼æ¥åˆ° `returnFiber` çš„ `Effect` é“¾æ¡ä¸Š(è¿™ä¸ªé“¾æ¡æ˜¯å·²ç»å¤„ç†å®Œçš„å­èŠ‚ç‚¹çš„ä¸æ˜¯è¿™ä¸ª `fiber` è‡ªå·±çš„)ï¼Œä¹‹ååˆ¤æ–­ `effectTag > PerformedWork`ï¼Œè¡¨ç¤ºè¿™ä¸ª `fiber` æ˜¯å¦æœ‰å‰¯ä½œç”¨æ“ä½œï¼Œå¦‚æœæœ‰æŠŠå®ƒè‡ªå·±ä¹Ÿæ‰”åˆ° `returnFiber`çš„ `Effect` é“¾æ¡ä¸Šã€‚
  + æœ€ååˆ¤æ–­ `siblingFiber !== null`ï¼Œå›å¿†ä¸€ä¸‹ `beginWork` çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬ä¸æ–­å‘ä¸‹é€’å½’ï¼Œè¿™ä¸ªè¿‡ç¨‹åªåˆå§‹åŒ–äº†æ¯ä¸€å±‚çš„ç¬¬ä¸€ä¸ª `fiber` ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ªé‡Œè¦å‘å³æ‹“å±•æœ‰å…„å¼ŸèŠ‚ç‚¹å°±è¿”å›å…„å¼ŸèŠ‚ç‚¹ï¼Œä¹‹åå°±ä¼šç»§ç»­èµ° `beginWork`ã€‚
  + ä¸ç„¶å°±ç»§ç»­å¯¹çˆ¶èŠ‚ç‚¹æ‰§è¡Œ `completeUnitOfWork`ï¼Œç›´åˆ°æ²¡æœ‰ `returnFiber`(åˆ°è¾¾ `RootFiber`)ä¸ºæ­¢ï¼Œè¿™ä¸ªæ—¶å€™ `workLoop` ä¹Ÿä¼šé€€å‡ºã€‚

[react-reconciler/src/ReactFiberScheduler.js]()

```ts
function completeUnitOfWork(workInProgress: Fiber): Fiber | null {
  // Attempt to complete the current unit of work, then move to the
  // next sibling. If there are no more siblings, return to the
  // parent fiber.
  while (true) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    const current = workInProgress.alternate;

    const returnFiber = workInProgress.return;   // çˆ¶èŠ‚ç‚¹
    const siblingFiber = workInProgress.sibling; // å…„å¼ŸèŠ‚ç‚¹

    if ((workInProgress.effectTag & Incomplete) === NoEffect) {
      // This fiber completed.
      nextUnitOfWork = completeWork(
        current,
        workInProgress,
        nextRenderExpirationTime,
      );
      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);

      if (
        returnFiber !== null &&
        // Do not append effects to parents if a sibling failed to complete
        (returnFiber.effectTag & Incomplete) === NoEffect
      ) {
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }
        const effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }
      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        return null;
      }
    } else {
      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      const next = unwindWork(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        next.effectTag &= HostEffectMask;
        return next;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.effectTag |= Incomplete;
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        return null;
      }
    }
  }

  // Without this explicit null return Flow complains of invalid return type
  // TODO Remove the above while(true) loop
  // eslint-disable-next-line no-unreachable
  return null;
}
```

## 2. completeWork

`completeWork` è¿™ä¸ªå‡½æ•°åœ¨ `beginWork`å®Œæˆé˜¶æ®µå¯¹ `fiber` è¿›è¡Œä¸€äº›æ“ä½œï¼Œä¸è¿‡é™¤äº† `HostComponent` å’Œ `HostText` ä¹‹å¤–åŸºæœ¬éƒ½æ˜¯æ— æ“ä½œï¼Œ`SuspenseComponent` å’Œ `Ref` æ—¥åå•ç‹¬è®²è§£ï¼š

[react-reconciler/src/ReactFiberCompleteWork.js]()

```ts
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderExpirationTime: ExpirationTime,
): Fiber | null {
  const newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
      break;
    case LazyComponent:
      break;
    case SimpleMemoComponent:
    case FunctionComponent:
      break;
    case ClassComponent: {
      break;
    }
    case HostRoot: {
      updateHostContainer(workInProgress);
      break;
    }
    case HostComponent: {
      // fucking long code
      break;
    }
    case HostText: {
      // not very long code
      break;
    }
    case ForwardRef:
      break;
    case SuspenseComponent: {
      const nextState = workInProgress.memoizedState;
      const prevState = current !== null ? current.memoizedState : null;
      const nextDidTimeout = nextState !== null && nextState.didTimeout;
      const prevDidTimeout = prevState !== null && prevState.didTimeout;
      if (nextDidTimeout !== prevDidTimeout) {
        // If this render commits, and it switches between the normal state
        // and the timed-out state, schedule an effect.
        workInProgress.effectTag |= Update;
      }
      break;
    }
    case Fragment:
      break;
    case Mode:
      break;
    case Profiler:
      break;
    case HostPortal:
      updateHostContainer(workInProgress);
      break;
    case ContextProvider:
      break;
    case ContextConsumer:
      break;
    case MemoComponent:
      break;
    case IncompleteClassComponent: {
      break;
    }
    default:
      invariant...
  }

  return null;
}
```

### 2.1 HostRoot

å¯¹ `hostComponent` æ‰§è¡Œ `completeWork` çš„æ—¶å€™ï¼Œå…¶å®è¿™ä¸ª `updateHostContainer` åœ¨ `react-dom` ç¯å¢ƒä¸‹ä»€ä¹ˆä¹Ÿä¸ä¼šæ‰§è¡Œæ‰€ä»¥å’Œç›´æ¥ `break` æ²¡å·®ã€‚

```ts
if (supportsMutation) {
	updateHostContainer = function(workInProgress: Fiber) {
    // Noop
  };
}
```

### 2.2 HostComponent

```ts
case HostComponent: {
  const rootContainerInstance = getRootHostContainer(); // context
  const type = workInProgress.type;
  if (current !== null && workInProgress.stateNode != null) {
    updateHostComponent(
      current,
      workInProgress,
      type,
      newProps,
      rootContainerInstance,
    );
  } else {
    let instance = createInstance(
      type,
      newProps,
      rootContainerInstance,
      currentHostContext,
      workInProgress,
    );

    appendAllChildren(instance, workInProgress, false, false);

    // Certain renderers require commit-time effects for initial mount.
    // (eg DOM renderer supports auto-focus for certain elements).
    // Make sure such renderers get scheduled for later work.
    if (
      finalizeInitialChildren(
        instance,
        type,
        newProps,
        rootContainerInstance,
        currentHostContext,
      )
    ) {
      markUpdate(workInProgress);
    }
    workInProgress.stateNode = instance;
  }
  break;
}
```

å®Œæˆ `HostCompoent` çš„æ¸²æŸ“åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š

+ ç¬¬ä¸€ç§æ˜¯éåˆæ¬¡æ¸²æŸ“æœ‰ `current` å’Œ `stateNode`ï¼Œèµ° `updateHostComponent`ã€‚
+ ç¬¬äºŒç§æ˜¯åˆæ¬¡æ¸²æŸ“è¿™ä¸ªæ—¶å€™è¦å…ˆåˆ›å»º `createInstance` å®ä¾‹ç„¶åæ·»åŠ ä»–çš„ `dom` å­èŠ‚ç‚¹ï¼Œæœ€åé€šè¿‡ `finalizeInitialChildren` åˆå§‹åŒ–äº‹ä»¶æœºåˆ¶å’Œ `dom` å±æ€§ï¼›
+ æœ€åéƒ½è¦æ·»åŠ  `stateNode`ï¼›

> [å°è´´å£«ï¼š]()ä¹‹æ‰€ä»¥æˆ‘ä»¬èƒ½æ·»åŠ å­èŠ‚ç‚¹ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬æ˜¯ä»ä¸‹å¾€ä¸Šéå†çš„ï¼Œæ²¡é”™ `domTree` æ˜¯åœ¨ `complete`é˜¶æ®µè‡ªä¸‹è€Œä¸Šæ„å»ºçš„. 

#### 2.2.1 updateHostComponent

`HostComponent` çš„ `updateQueue` å’Œ `Component` çš„ä¸å¤ªä¸€æ ·ï¼Œæ˜¯ä¸€ä¸ª `[...k, v]` çš„æ•°ç»„è®°å½•çš„æ˜¯è¦æ›´æ–°çš„ `props` æœ€åä¼šåœ¨ `commit` é˜¶æ®µæ›´æ–°ï¼Œå¹¶ä¸æ˜¯ `update` å¯¹è±¡ã€‚

`updateHostComponent` è¿™ä¸ªå‡½æ•°ç”¨äºå¯¹å·²æœ‰ `HostComponent`çš„ `fiber` åšæ›´æ–°ï¼Œæ¶‰åŠä¸€ç§ `diff` æ¯”è¾ƒï¼Œæ·»åŠ æ‰€æœ‰å±æ€§å˜åŒ–åˆ°ä¸€ä¸ª `updatePayload` é‡Œé¢ç„¶åèµ‹ç»™ `wip.updateQueue`ï¼Œç„¶å `markUpdate(workInProgress.effectTag |= Update;)`æ·»åŠ æ›´æ–°æ ‡è®°ä½ã€‚å½“ç„¶å¦‚æœ `oldProps === newProps`é‚£å°±è¡¨ç¤ºå®Œå…¨æ²¡æœ‰å±æ€§æ”¹å˜ï¼š

> [æ³¨æ„ï¼š]()è¿™é‡Œåªæ˜¯å¯¹ `HostComponent` çš„ `fiber` çš„` props` åšæ›´æ–°æ ‡è®°ï¼Œé€šè¿‡ `updateQueue` ç¼“å­˜æ›´æ–°å†…å®¹ï¼Œå®é™…çš„ `dom` å±æ€§æ›´æ–°åœ¨ `commit` é˜¶æ®µè¿›è¡Œã€‚

[react-reconciler/src/ReactFiberCompleteWork.js]()

```ts
updateHostComponent = function(
 current: Fiber,
 workInProgress: Fiber,
 type: Type,
 newProps: Props,
 rootContainerInstance: Container,
) {
  // If we have an alternate, that means this is an update and we need to
  // schedule a side-effect to do the updates.
  const oldProps = current.memoizedProps;
  if (oldProps === newProps) {
    // In mutation mode, this is sufficient for a bailout because
    // we won't touch this node even if children changed.
    return;
  }

  // If we get updated because one of our children updated, we don't
  // have newProps so we'll have to reuse them.
  // TODO: Split the update API as separate for the props vs. children.
  // Even better would be if children weren't special cased at all tho.
  const instance: Instance = workInProgress.stateNode;
  const currentHostContext = getHostContext();
  // TODO: Experiencing an error where oldProps is null. Suggests a host
  // component is hitting the resume path. Figure out why. Possibly
  // related to `hidden`.
  const updatePayload = prepareUpdate(
    instance,
    type,
    oldProps,
    newProps,
    rootContainerInstance,
    currentHostContext,
  );
  // TODO: Type this specific to this type of component.
  workInProgress.updateQueue = (updatePayload: any);
  // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update. All the work is done in commitWork.
  if (updatePayload) {
    markUpdate(workInProgress);
  }
};

function markUpdate(workInProgress: Fiber) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.effectTag |= Update;
}
```

`prepareUpdate` è°ƒç”¨ `diffProperties` è¿›è¡Œ `dom` å±æ€§æ¯”è¾ƒï¼Œå°†æœ‰æ›´æ–°æ›´æ–°çš„å±æ€§æ·»åŠ åˆ° `updatePayload` ä¹‹ä¸­ï¼Œå¤§æ¦‚åˆ†ä¸€ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š

+ æ·»åŠ è¦åœ¨ `oldProps` åˆ é™¤çš„å±æ€§
+ æ·»åŠ  `nextProps` æ–°å¢çš„å±æ€§ï¼›

é¦–å…ˆå¯¹äº `input|option|select|textarea`è¿™å‡ ä¸ªå…ƒç´ ä¸€å®šä¼šç”Ÿæˆ `updatePayload`ï¼Œå› ä¸ºè¿™å‡ ä¸ªå¯èƒ½æ˜¯éå—æ§ç»„ä»¶ï¼š

[react-dom/src/client/ReactDOMComponent.js]()

```ts
export function prepareUpdate(
  domElement: Instance,
  type: string,
  oldProps: Props,
  newProps: Props,
  rootContainerInstance: Container,
  hostContext: HostContext,
): null | Array<mixed> {
  return diffProperties(
    domElement,
    type,
    oldProps,
    newProps,
    rootContainerInstance,
  );
}
// Calculate the diff between the two objects.
export function diffProperties(
  domElement: Element,
  tag: string,
  lastRawProps: Object,
  nextRawProps: Object,
  rootContainerElement: Element | Document,
): null | Array<mixed> {
  let updatePayload: null | Array<any> = null;

  let lastProps: Object;
  let nextProps: Object;
  switch (tag) {
    case 'input':
      lastProps = ReactDOMInput.getHostProps(domElement, lastRawProps);
      nextProps = ReactDOMInput.getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = ReactDOMOption.getHostProps(domElement, lastRawProps);
      nextProps = ReactDOMOption.getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = ReactDOMSelect.getHostProps(domElement, lastRawProps);
      nextProps = ReactDOMSelect.getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = ReactDOMTextarea.getHostProps(domElement, lastRawProps);
      nextProps = ReactDOMTextarea.getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (
        typeof lastProps.onClick !== 'function' &&
        typeof nextProps.onClick === 'function'
      ) {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(((domElement: any): HTMLElement));
      }
      break;
  }
/...
```

ä¹‹åæ˜¯ä¸€ä¸ªå¾ªç¯éå† `lastProps` çš„  `propKey`ï¼Œè¿™ä¸ªå¾ªç¯ç”¨äºæ£€æµ‹ `nextProps` æ²¡æœ‰ä½†æ˜¯ `lastProps` ä¸Šæœ‰çš„å±æ€§(åˆ é™¤çš„å±æ€§)ï¼Œæ ¹æ®å±æ€§ä¸åŒæœ‰ä¸åŒçš„æ‰§è¡Œæ•ˆæœï¼š

+ `STYLE`ï¼šæ¸…ç©ºè€çš„ `prop` çš„`style`å¯¹è±¡çš„æ‰€æœ‰å±æ€§çš„å€¼ï¼Œä½†æ˜¯ä¿ç•™è¿™ä¸ª `style` å¯¹è±¡ä»¥åŠå®ƒçš„é”®ã€‚
+ `etc`ï¼šç»™è€çš„ `prop`çš„å±æ€§çš„å€¼éƒ½èµ‹äºˆ `null` è¿›è¡Œæ¸…ç©ºã€‚

```ts
  let propKey;
  let styleName;
  let styleUpdates = null;
  for (propKey in lastProps) {
    if (
      nextProps.hasOwnProperty(propKey) ||
      !lastProps.hasOwnProperty(propKey) ||
      lastProps[propKey] == null
    ) {
      continue;
    }
    if (propKey === STYLE) {
      const lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (
      propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
      propKey === SUPPRESS_HYDRATION_WARNING
    ) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
```

è¿™ä¸ªæ˜¯éå†æ‰€æœ‰æ–°çš„ `props` ä¸ŠğŸˆ¶ï¸ä¸”å’Œè€çš„ `props` ä¸Šä¸ç›¸åŒçš„å±æ€§ï¼ˆæ–°å±æ€§ï¼‰ï¼š

+ `STYLE`ï¼šè¿™ä¸ªç•¥æœ‰ä¸åŒé¦–å…ˆå®ƒè¿™ä¸ª `styleUpdate` å…ˆåœ¨ `lastProp` ä¸Šæ”¶é›†äº† `styleName` å…¨éƒ¨è®¾ç½®ä¸º `""`ç©ºå­—ç¬¦ä¸²ï¼Œç„¶ååœ¨ `newProp` ä¸Šæ”¶é›†äº† `styleName` ç»™åˆšåˆšçš„å¯¹è±¡èµ‹äºˆå€¼ï¼Œè¿™æ ·å°±æ—¢æœ‰äº†åˆ é™¤çš„å±æ€§åˆæœ‰æ–°å¢çš„å±æ€§ã€‚
+ æ€»ä¹‹æ–°å±æ€§ä¼šä»¥ä¸€ä¸ª `key` ä¸€ä¸ª `value` çš„å½¢å¼æ¨å…¥`updatePayload`ã€‚

```ts
  for (propKey in nextProps) {
    const nextProp = nextProps[propKey];
    const lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (
      !nextProps.hasOwnProperty(propKey) ||
      nextProp === lastProp ||
      (nextProp == null && lastProp == null)
    ) {
      continue;
    }
    if (propKey === STYLE) {
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (
            lastProp.hasOwnProperty(styleName) &&
            (!nextProp || !nextProp.hasOwnProperty(styleName))
          ) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (
            nextProp.hasOwnProperty(styleName) &&
            lastProp[styleName] !== nextProp[styleName]
          ) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      const nextHtml = nextProp ? nextProp[HTML] : undefined;
      const lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (
        lastProp !== nextProp &&
        (typeof nextProp === 'string' || typeof nextProp === 'number')
      ) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (
      propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
      propKey === SUPPRESS_HYDRATION_WARNING
    ) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (__DEV__ && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}
```

#### 2.2.2 createInstance

[react-dom/src/client/ReactDOMHostConfig.js]()

 ```ts
export function createInstance(
  type: string,
  props: Props,
  rootContainerInstance: Container,
  hostContext: HostContext,
  internalInstanceHandle: Object,
): Instance {
  const domElement: Instance = createElement(
    type,
    props,
    rootContainerInstance,
    parentNamespace,
  );
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
}
 ```

è¿™ä¸ªå‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ª `dom` å…ƒç´ å®ä¾‹å¹¶ä¸”å’Œ `fiber ` å»ºç«‹è”ç³»ï¼Œå…¶ä¸­ `createElement` çš„ä»£ç æˆ‘å•ç‹¬æ”¾åˆ°`  dom`ç›¸å…³æ“ä½œçš„éƒ¨åˆ†è®²è§£ã€‚

å…¶ä¸­çš„ `precacheFiberNode` ç”¨äºåœ¨`instance` ä¸Šå’Œ  `workInProgress`å»ºç«‹è”ç³»ï¼š

```ts
const randomKey = Math.random()
  .toString(36)
  .slice(2);
const internalInstanceKey = '__reactInternalInstance$' + randomKey;

export function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}
```

è€Œ `updateFiberProps` ç”¨äºå°† `instance` å’Œ `props` å»ºç«‹è”ç³»ï¼š

```ts
export function updateFiberProps(node, props) {
  node[internalEventHandlersKey] = props;
}
```

#### 2.2.3 appendAllChildren

[react-reconciler/src/ReactFiberCompleteWork.js]()

```ts
function appendAllChildren(
 parent: Instance,
 workInProgress: Fiber,
 needsVisibilityToggle: boolean,
 isHidden: boolean,
) {
  let node = workInProgress.child;
  while (node !== null) {
    if (node.tag === HostComponent || node.tag === HostText) {
      appendInitialChild(parent, node.stateNode);
    } else if (node.tag === HostPortal) {
      // If we have a portal child, then we don't want to traverse
      // down its children. Instead, we'll get insertions from each child in
      // the portal directly.
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === workInProgress) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
};
```

è¿™ä¸ªå‡½æ•°çš„å·¥ä½œæ˜¯å°† `parent` ä¸‹çš„ç¬¬ä¸€å±‚ `HostCompoentInstance|HostTextInstance` æ’å…¥åˆ°å…¶å­èŠ‚ç‚¹ä¸‹ï¼š

![fiberTree3 (5)](assets/fiberTree3 (5).png)

ä¸Šå›¾æ˜¯è¿™ä¸ªå‡½æ•°å®ç°çš„å¤§æ¦‚æ•ˆæœï¼Œå®é™…çš„å®ç°è¿‡ç¨‹ä¹Ÿå¾ˆç®€å•ï¼Œä»–çš„éå†é¡ºåºå¦‚ä¸‹ï¼š

+ å‡è®¾ä¸€å¼€å§‹æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹çš„ä½ç½®ï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ä¸ªåŸç”ŸèŠ‚ç‚¹ï¼Œé‚£å°±ä½¿ç”¨  `appendInitialChild` è¿›è¡Œæ’å…¥ï¼Œä¹‹å `node = node.sibling` èµ°ä»–çš„å…„å¼ŸèŠ‚ç‚¹ï¼›
+ å¦‚æœè¿™ä¸ªèŠ‚ç‚¹ä¸æ˜¯åŸç”ŸèŠ‚ç‚¹ï¼Œé‚£å°±èµ° `node = node.child` å‘ä¸‹æ·±å…¥ä¸€å±‚ï¼›
+ å½“æˆ‘ä»¬ä¸æ–­æ·±å…¥ç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŸç”ŸèŠ‚ç‚¹(æˆ–è€…æ²¡æ‰¾åˆ°)ï¼Œè¿™ä¸ªæ—¶å€™æ‰¾å…„å¼ŸèŠ‚ç‚¹ `node = node.sibling`ï¼Œå¯¹ `node.sibling` å†æ‰§è¡Œä¸€éä¸Šè¿°é€»è¾‘ï¼Œæœ€åä¼šåœ¨æ²¡æœ‰ `sibling` çš„æ—¶å€™ä¸æ–­è¿”å›å›åˆ° `WIP` ç»ˆæ­¢ã€‚

`appendInitialChild` è¿™ä¸ªå‡½æ•°å°±æ¯”è¾ƒç®€å•ï¼š

[react-dom/src/client/ReactDOMHostConfig.js]()

```ts
export function appendInitialChild(
  parentInstance: Instance,
  child: Instance | TextInstance,
): void {
  parentInstance.appendChild(child);
}
```

#### 2.2.4 finalizeInitialChildren

`finalizeInitialChildren` è¿™ä¸ªå‡½æ•°ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼š

+ è°ƒç”¨ `setInitialProperties` åœ¨ `dom` å®ä¾‹ä¸Šåˆå§‹åŒ–å±æ€§(è¯¦è§[dom](//TODO))ï¼Œè°ƒç”¨ `shouldAutoFocusHostComponent` è¿”å›å…ƒç´ æ˜¯å¦ `autoFocus`ï¼š

[react-dom/src/client/ReactDOMHostConfig.js]() 

```ts
export function finalizeInitialChildren(
  domElement: Instance,
  type: string,
  props: Props,
  rootContainerInstance: Container,
  hostContext: HostContext,
): boolean {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}
```

`autoFocus`è¿™ä¸ªå±æ€§åªæœ‰è¡¨å•ç›¸å…³å…ƒç´ å¯ä»¥è®¾ç½®ï¼Œæ‰€ä»¥ `shouldAutoFocusHostComponent` åšäº†ä¸€äº›åˆ¤æ–­ï¼š

[react-dom/src/client/ReactDOMHostConfig.js]() 

```ts
function shouldAutoFocusHostComponent(type: string, props: Props): boolean {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}
```

è¿™é‡Œæœ‰`autoFocus`å±æ€§è¿˜è¦è®¾ç½®ä¸€ä¸‹ `update` æ ‡è®°ä½ï¼Œ`autoFocus`ä¼šåœ¨ `commit` é˜¶æ®µè¢«è®¾ç½®ï¼š

```ts
function markUpdate(workInProgress: Fiber) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.effectTag |= Update;
}
```

### 2.3 HostText

[react-reconciler/src/ReactFiberCompleteWork.js]()

```ts
case HostText {
  let newText = newProps;
  if (current && workInProgress.stateNode != null) {
    const oldText = current.memoizedProps;
    // If we have an alternate, that means this is an update and we need
    // to schedule a side-effect to do the updates.
    updateHostText(current, workInProgress, oldText, newText);
  } else {
    if (typeof newText !== 'string') {
      invariant(
        workInProgress.stateNode !== null,
        'We must have new props for new mounts. This error is likely ' +
        'caused by a bug in React. Please file an issue.',
      );
      // This can happen when we abort work.
    }
    const rootContainerInstance = getRootHostContainer();
    workInProgress.stateNode = createTextInstance(
      newText,
      rootContainerInstance,
      currentHostContext,
      workInProgress,
    );
  }
	break;
}
```

è¿™ä¸ªå‡½æ•°ä¹Ÿåˆ†ä¸¤ç§æƒ…å†µï¼š

+ ç¬¬ä¸€æ¬¡æ›´æ–°ï¼Œç¬¬ä¸€æ¬¡æ›´æ–°çš„è¯è°ƒç”¨ `createTextInstance` æ¥åˆ›å»ºä¸€ä¸ª `textNode`ã€‚
+ ç¬¬ `n+1` æ¬¡æ›´æ–°ï¼Œè°ƒç”¨ `updateHostText` è¿›è¡ŒèŠ‚ç‚¹æ›´æ–°ã€‚

`updateHostText` å°±æ˜¯åˆ¤æ–­ `oldText === newText` æ¥å†³å®šæ˜¯å¦è°ƒç”¨ `markUpdate`ï¼š

[react-reconciler/src/ReactFiberCompleteWork.js]()

```ts
updateHostText = function(
current: Fiber,
 workInProgress: Fiber,
 oldText: string,
 newText: string,
) {
  // If the text differs, mark it as an update. All the work in done in commitWork.
  if (oldText !== newText) {
    markUpdate(workInProgress);
  }
};
```

`createTextInstance` ç”¨äºåˆ›å»ºä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ï¼Œå®ƒæ ¹æ®ä¼ å…¥çš„ `rootContainerInstance` åˆ¤æ–­ `Document` çš„æ–‡æ¡£ç¯å¢ƒã€‚`precacheFiberNode` ç”¨äºå»ºç«‹` textNode` å’Œ `fiber` çš„è”ç³»ã€‚

[react-dom/src/client/ReactDOMHostConfig.js]()

```ts
export function createTextInstance(
  text: string,
  rootContainerInstance: Container,
  hostContext: HostContext,
  internalInstanceHandle: Object,
): TextInstance {
  const textNode: TextInstance = createTextNode(text, rootContainerInstance);
  precacheFiberNode(internalInstanceHandle, textNode);
  return textNode;
}
```

## 3. resetChildExpirationTime

æ¯ä¸€æ¬¡  `completeWork`ä¹‹åä»£è¡¨ä¸€ä¸ª `fiber` çš„æ›´æ–°é˜¶æ®µ(æ¸²æŸ“ `render` é˜¶æ®µ)å·²ç»å®Œæˆï¼Œæ‰€ä»¥è¦é‡ç½® `ChildExpirationTime`(å­èŠ‚ç‚¹ä¸­çš„æœ€é«˜ä¼˜å…ˆçº§)ï¼Œå°±æ˜¯åœ¨ `WIP`çš„ `child` ä¸­å¯»æ‰¾æœ€é«˜ä¼˜å…ˆçº§çš„ `expirationTime` å’Œ `ChildExpirationTime`æ¥ä¸ª `WIP` åšæ›´æ–°ï¼š

```ts
function resetChildExpirationTime(
  workInProgress: Fiber,
  renderTime: ExpirationTime,
) {
  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  let newChildExpirationTime = NoWork;

  // Bubble up the earliest expiration time.
  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
    // We're in profiling mode.
    // Let's use this same traversal to update the render durations.
    let actualDuration = workInProgress.actualDuration;
    let treeBaseDuration = workInProgress.selfBaseDuration;

    // When a fiber is cloned, its actualDuration is reset to 0.
    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration.
    // If the fiber has not been cloned though, (meaning no work was done),
    // Then this value will reflect the amount of time spent working on a previous render.
    // In that case it should not bubble.
    // We determine whether it was cloned by comparing the child pointer.
    const shouldBubbleActualDurations =
      workInProgress.alternate === null ||
      workInProgress.child !== workInProgress.alternate.child;

    let child = workInProgress.child;
    while (child !== null) {
      const childUpdateExpirationTime = child.expirationTime;
      const childChildExpirationTime = child.childExpirationTime;
      if (
        newChildExpirationTime === NoWork ||
        (childUpdateExpirationTime !== NoWork &&
          childUpdateExpirationTime < newChildExpirationTime)
      ) {
        newChildExpirationTime = childUpdateExpirationTime;
      }
      if (
        newChildExpirationTime === NoWork ||
        (childChildExpirationTime !== NoWork &&
          childChildExpirationTime < newChildExpirationTime)
      ) {
        newChildExpirationTime = childChildExpirationTime;
      }
      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }
      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }
    workInProgress.actualDuration = actualDuration;
    workInProgress.treeBaseDuration = treeBaseDuration;
  } else {
    let child = workInProgress.child;
    while (child !== null) {
      const childUpdateExpirationTime = child.expirationTime;
      const childChildExpirationTime = child.childExpirationTime;
      if (
        newChildExpirationTime === NoWork ||
        (childUpdateExpirationTime !== NoWork &&
          childUpdateExpirationTime < newChildExpirationTime)
      ) {
        newChildExpirationTime = childUpdateExpirationTime;
      }
      if (
        newChildExpirationTime === NoWork ||
        (childChildExpirationTime !== NoWork &&
          childChildExpirationTime < newChildExpirationTime)
      ) {
        newChildExpirationTime = childChildExpirationTime;
      }
      child = child.sibling;
    }
  }

  workInProgress.childExpirationTime = newChildExpirationTime;
}
```

