# Render State

![render_state](assets/render_state.png)

## 0. constants

==expirationContext==

ä¿å­˜åˆ›å»º`expirationTime`çš„ä¸Šä¸‹æ–‡ï¼Œåœ¨`syncUpdates`å’Œ`deferredUpdates`ä¸­åˆ†åˆ«è¢«è®¾ç½®ä¸º`Sync`å’Œ`AsyncExpirationTime`ï¼Œåœ¨æœ‰è¿™ä¸ªä¸Šä¸‹æ–‡çš„æ—¶å€™ä»»ä½•æ›´æ–°è®¡ç®—å‡ºæ¥çš„è¿‡æœŸæ—¶é—´éƒ½ç­‰äº`expirationContext`ã€‚

æ¯”å¦‚è°ƒç”¨`ReactDOM.flushSync`çš„æ—¶å€™ï¼Œä»–æ¥å—çš„å›è°ƒä¸­çš„`setState`

```ts
// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
let expirationContext: ExpirationTime = NoWork;
```

==isWorking==

`commitRoot`å’Œ`renderRoot`å¼€å§‹éƒ½ä¼šè®¾ç½®ä¸º`true`ï¼Œç„¶ååœ¨ä»–ä»¬å„è‡ªé˜¶æ®µç»“æŸçš„æ—¶å€™éƒ½é‡ç½®ä¸º`false`ã€‚

```ts
let isWorking: boolean = false;
```

==isCommitting==

`commitRoot`å¼€å¤´è®¾ç½®ä¸º`true`ï¼Œç»“æŸä¹‹åè®¾ç½®ä¸º`false`

```ts
let isCommitting: boolean = false;
```

**ç”¨æ¥æ ‡å¿—æ˜¯å¦å¤„äº`commit`é˜¶æ®µ**

==nextUnitOfWork==

ç”¨äºè®°å½•`render`é˜¶æ®µ`Fiber`æ ‘éå†è¿‡ç¨‹ä¸­ä¸‹ä¸€ä¸ªéœ€è¦æ‰§è¡Œçš„èŠ‚ç‚¹ã€‚

```ts
let nextUnitOfWork: Fiber | null = null;
```

åœ¨`resetStack`ä¸­åˆ†åˆ«è¢«é‡ç½®ï¼Œä»–åªä¼šæŒ‡å‘`workInProgress`(`alternate`)ï¼Œ

==nextRoot & nextRenderExpirationTime==

ç”¨äºè®°å½•**ä¸‹ä¸€ä¸ªå°†è¦æ¸²æŸ“çš„`root`èŠ‚ç‚¹**å’Œ**ä¸‹ä¸€ä¸ªè¦æ¸²æŸ“çš„ä»»åŠ¡çš„`ExpirationTime`** 

```ts
let nextRoot: FiberRoot | null = null;
// The time at which we're currently rendering work.
let nextRenderExpirationTime: ExpirationTime = NoWork;
```

åœ¨`renderRoot`å¼€å§‹çš„æ—¶å€™èµ‹å€¼ï¼Œéœ€è¦ç¬¦åˆå¦‚ä¸‹æ¡ä»¶æ‰ä¼šé‡æ–°èµ‹å€¼

```js
if (
  expirationTime !== nextRenderExpirationTime ||
  root !== nextRoot ||
  nextUnitOfWork === null
) {
  resetStack()
  nextRoot = root
  nextRenderExpirationTime = expirationTime
  nextUnitOfWork = createWorkInProgress(
    nextRoot.current,
    null,
    nextRenderExpirationTime,
  )
}
```

è§£é‡Šä¸€ä¸‹å°±æ˜¯è¯´ï¼Œåªæœ‰è¿™ä¸€æ¬¡è°ƒç”¨`renderRoot`çš„æ—¶å€™ï¼Œæœ‰

- æ–°çš„`root`è¦æ¸²æŸ“ã€‚
- ç›¸åŒçš„`root`ä½†æ˜¯ä»»åŠ¡æœ‰ä¸åŒä¼˜å…ˆçº§çš„ä»»åŠ¡è¦æ¸²æŸ“ã€‚
- ç¬¬ä¸€æ¬¡æ¸²æŸ“ï¼Œæˆ–è€…ç°åœ¨æ­£å¥½ç©ºé—²æ²¡æœ‰èŠ‚ç‚¹è¦æ¸²æŸ“ã€‚

åœ¨è¿™é‡Œæˆ‘ä»¬é€šè¿‡ `current` æ„å»º `FiberRoot` å¯¹åº”çš„ `RootFiber` çš„ `workInProgress`ä½œä¸º `nextUnitOfWork`æ¥æ„å»ºæœ¬è½®çš„ `fiberTree`ã€‚å¦‚æœè¯´ `current` å­˜åœ¨ï¼Œ`current` ä¼šä½œä¸ºå‚è€ƒï¼Œå¤ç”¨ä¸€äº›ä¸Šä¸€æ¬¡æ¸²æŸ“çš„ `fiber`ã€‚

![fiberTree3 (6)](assets/fiberTree3 (6).png)

å¦‚æœè¯´ `workInProgress` æœ¬æ¥å°±å­˜åœ¨é‚£ä¹ˆ `createWorkInProgress` ä¸­ä¼šå¯¹å…¶è¿›è¡Œä¸€å®šçš„å¤ç”¨ï¼Œä½†æ˜¯ä½œä¸ºä¸Šä¸Šä¸€è½®çš„ `fiberTree`å·²ç»å¤±å»äº†å­˜åœ¨çš„æ„ä¹‰ï¼Œå…¶ `child` å’Œ `sibling` éƒ½ä¼šé‡ç½®ä¸º `current` çš„ `child` å’Œ `sibling`ã€‚

==nextEffect==

ç”¨äº`commit`é˜¶æ®µè®°å½•`firstEffect -> lastEffect`é“¾éå†è¿‡ç¨‹ä¸­çš„æ¯ä¸€ä¸ª`Fiber`

```ts
// The next fiber with an effect that we're currently committing.
let nextEffect: Fiber | null = null;
```

==interruptedBy==

ç»™å¼€å‘å·¥å…·ç”¨çš„ï¼Œç”¨æ¥å±•ç¤ºè¢«å“ªä¸ªèŠ‚ç‚¹æ‰“æ–­äº†å¼‚æ­¥ä»»åŠ¡ï¼š

```ts
// Used for performance tracking.
let interruptedBy: Fiber | null = null;
```

## 1. renderRoot

[react-reconciler/src/ReactFiberScheduler.js]()

```tsx
function renderRoot(
  root: FiberRoot,
  isYieldy: boolean,
  isExpired: boolean,
): void {
  isWorking = true;
  const expirationTime = root.nextExpirationTimeToWorkOn;

  // Check if we're starting from a fresh stack, or if we're resuming from
  // previously yielded work.
  if (
    expirationTime !== nextRenderExpirationTime ||
    root !== nextRoot ||
    nextUnitOfWork === null
  ) {
    // Reset the stack and start working from the root.
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;	// è™½ç„¶è¿™é‡Œéƒ½æ˜¯ nextxxxx ä½†æ˜¯å…¶å®å°±æ˜¯æŒ‡æœ¬è½®
    nextUnitOfWork = createWorkInProgress(	// nextUnitOfWork = workInProgress
      nextRoot.current,
      null,
      nextRenderExpirationTime,
    );
    root.pendingCommitExpirationTime = NoWork;
  }

  let didFatal = false;
  do {
    try {
      workLoop(isYieldy); // isYieldy æ˜¯å¦å¯æ‰“æ–­
    } catch (thrownValue) {
      if (nextUnitOfWork === null) {
        // This is a fatal error.
        didFatal = true;
        onUncaughtError(thrownValue);
      } else {
        const failedUnitOfWork: Fiber = nextUnitOfWork;
        const sourceFiber: Fiber = nextUnitOfWork;
        let returnFiber = sourceFiber.return;
        if (returnFiber === null) {
          // This is the root. The root could capture its own errors. However,
          // we don't know if it errors before or after we pushed the host
          // context. This information is needed to avoid a stack mismatch.
          // Because we're not sure, treat this as a fatal error. We could track
          // which phase it fails in, but doesn't seem worth it. At least
          // for now.
          didFatal = true;
          onUncaughtError(thrownValue);
        } else {
          throwException(
            root,
            returnFiber,
            sourceFiber,
            thrownValue,
            nextRenderExpirationTime,
          );
          nextUnitOfWork = completeUnitOfWork(sourceFiber);
          continue;
        }
      }
    }
    break;
  } while (true);

  // We're done performing work. Time to clean up.
  isWorking = false;

  // Yield back to main thread.
  if (didFatal) {
    const didCompleteRoot = false;
    stopWorkLoopTimer(interruptedBy, didCompleteRoot);
    interruptedBy = null;
    // `nextRoot` points to the in-progress root. A non-null value indicates
    // that we're in the middle of an async render. Set it to null to indicate
    // there's no more work to be done in the current batch.
    nextRoot = null;
    onFatal(root);
    return;
  }

  if (nextUnitOfWork !== null) {
    // There's still remaining async work in this tree, but we ran out of time
    // in the current frame. Yield back to the renderer. Unless we're
    // interrupted by a higher priority update, we'll continue later from where
    // we left off.
    const didCompleteRoot = false;
    stopWorkLoopTimer(interruptedBy, didCompleteRoot);
    interruptedBy = null;
    onYield(root);
    return;
  }

  // We completed the whole tree.
  const didCompleteRoot = true;
  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
  const rootWorkInProgress = root.current.alternate;
  invariant(
    rootWorkInProgress !== null,
    'Finished root should have a work-in-progress. This error is likely ' +
      'caused by a bug in React. Please file an issue.',
  );

  // `nextRoot` points to the in-progress root. A non-null value indicates
  // that we're in the middle of an async render. Set it to null to indicate
  // there's no more work to be done in the current batch.
  nextRoot = null;
  interruptedBy = null;

  if (nextRenderDidError) {
    // There was an error
    if (hasLowerPriorityWork(root, expirationTime)) {
      // There's lower priority work. If so, it may have the effect of fixing
      // the exception that was just thrown. Exit without committing. This is
      // similar to a suspend, but without a timeout because we're not waiting
      // for a promise to resolve. React will restart at the lower
      // priority level.
      markSuspendedPriorityLevel(root, expirationTime);
      const suspendedExpirationTime = expirationTime;
      const rootExpirationTime = root.expirationTime;
      onSuspend(
        root,
        rootWorkInProgress,
        suspendedExpirationTime,
        rootExpirationTime,
        -1, // Indicates no timeout
      );
      return;
    } else if (
      // There's no lower priority work, but we're rendering asynchronously.
      // Synchronsouly attempt to render the same level one more time. This is
      // similar to a suspend, but without a timeout because we're not waiting
      // for a promise to resolve.
      !root.didError &&
      !isExpired
    ) {
      root.didError = true;
      const suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime);
      const rootExpirationTime = (root.expirationTime = Sync);
      onSuspend(
        root,
        rootWorkInProgress,
        suspendedExpirationTime,
        rootExpirationTime,
        -1, // Indicates no timeout
      );
      return;
    }
  }

  if (!isExpired && nextLatestAbsoluteTimeoutMs !== -1) {
    // The tree was suspended.
    const suspendedExpirationTime = expirationTime;
    markSuspendedPriorityLevel(root, suspendedExpirationTime);

    // Find the earliest uncommitted expiration time in the tree, including
    // work that is suspended. The timeout threshold cannot be longer than
    // the overall expiration.
    const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
      root,
      expirationTime,
    );
    const earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
    }

    // Subtract the current time from the absolute timeout to get the number
    // of milliseconds until the timeout. In other words, convert an absolute
    // timestamp to a relative time. This is the value that is passed
    // to `setTimeout`.
    const currentTimeMs = expirationTimeToMs(requestCurrentTime());
    let msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;

    // TODO: Account for the Just Noticeable Difference

    const rootExpirationTime = root.expirationTime;
    onSuspend(
      root,
      rootWorkInProgress,
      suspendedExpirationTime,
      rootExpirationTime,
      msUntilTimeout,
    );
    return;
  }

  // Ready to commit.
  onComplete(root, rootWorkInProgress, expirationTime);
}
```

è¿™ä¸ªå‡½æ•°æœ‰ç‚¹é•¿ï¼Œæˆ‘ç”»ä¸€å¼ å›¾è§£é‡Šå®ƒçš„å¤§æ¦‚æµç¨‹ï¼š

![renderRoot (1)](assets/renderRoot (1).png)

è¿›å…¥ `renderRoot`ä¹‹ååˆ¤æ–­å½“å‰ä»»åŠ¡æ˜¯ä¸æ˜¯ä¸€ä¸ªæ‰“æ–­çš„ä»»åŠ¡ï¼Œéœ€è¦è¿›è¡Œä¸€äº›å…¨å±€å˜é‡åˆå§‹åŒ–ï¼Œä¹‹åè¿›å…¥ `workLoop` ä¸€æ—¦åœ¨ `workLoop` ä¸­æŠ›å‡ºé”™è¯¯å°±ç”± `throwExpection` å’Œ `completeUnitOfWork` å¤„ç†ç„¶åå›åˆ° `workLoop`ã€‚

## 2. workLoop

[react-reconciler/src/ReactFiberScheduler.js]()

```ts
function workLoop(isYieldy) {
  if (!isYieldy) {
    // Flush work without yielding
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    // Flush asynchronous work until the deadline runs out of time.
    while (nextUnitOfWork !== null && !shouldYield()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
```

`workLoop` å°±æ˜¯ä¸æ–­çš„é€šè¿‡è°ƒç”¨ `performUnitOfWork`ï¼š

### 2.1 performUnitOfWork

[react-reconciler/src/ReactFiberScheduler.js]()

```ts
function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;

  // See if beginning this work spawns more work.
  startWorkTimer(workInProgress);

  let next;
  if (enableProfilerTimer) {
    if (workInProgress.mode & ProfileMode) {
      startProfilerTimer(workInProgress);
    }

    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;

    if (workInProgress.mode & ProfileMode) {
      // Record the render duration assuming we didn't bailout (or error).
      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
    }
  } else {
    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
  }

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    next = completeUnitOfWork(workInProgress);
  }

  ReactCurrentOwner.current = null;
  return next;
}
```

è¿™ä¸ªå‡½æ•°æŒ‰ç…§ä¸€ä¸ªæ·±åº¦ä¼˜å…ˆéå†çš„é¡ºåºæ„å»º `fiber` æ ‘ã€‚

## 3. work flow

ç›¸ä¿¡è¯´åˆ°è¿™é‡Œå¤§å®¶éƒ½æ‡µäº†ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘æ‹¿ä¸€ä¸ªå®é™…çš„ `ElementTree` æ„å»º `fiberTree` çš„è¿‡ç¨‹æ¥æ¼”ç¤ºä¸€ä¸‹ï¼Œè¿™éƒ¨åˆ†æ¨èå¤§å®¶åœ¨è¯»å®Œ `3.8` ä¹‹åå›è¿‡æ¥çœ‹ï¼Œè¿™æ ·ç†è§£çš„æ¯”è¾ƒæ¸…æ¥šã€‚

### 3.1 beginWork

åœ¨æ —å­ğŸŒ°é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸‹é¢è¿™ä¸ªç®€å•çš„ `domTree` ä½œä¸ºç¬¬ä¸€æ¬¡æ„å»ºçš„å¯¹è±¡ï¼š

![renderWorkFlow-1 (1)](assets/renderWorkFlow-1 (1).png)

è·³è¿‡å‰é¢æ„å»º `fiberRoot` å’Œ `HostRootFIber`çš„è¿‡ç¨‹ï¼Œç°åœ¨æ‰§è¡Œ `renderRoot`ï¼Œç”±äº `nextUnitOfWork === null` æ‰€ä»¥æ‰§è¡Œ `resetStack` ç­‰ä¸€ç³»åˆ—åˆå§‹åŒ–ï¼Œå¹¶ä¸”ç»™ `HostRootFiber` è®¾ç½® `WIP`ä½œä¸º `nextUnitOfWork`ï¼š

![fiberTree3 (6)](assets/fiberTree3 (6).png)

ä¹‹åä¼šå¯¹ `HostRootFiber` çš„ `alternate` æ‰§è¡Œ `beginWork`ï¼Œå‘½ä¸­ `HostRoot` çš„åˆ†æ”¯èµ°`updateHostRoot`ï¼Œç”±äºæ˜¯ç¬¬ä¸€æ¬¡æ›´æ–°å¹¶ä¸”åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹æ‰€ä»¥ç›´æ¥ `reconcileSingleElement`ï¼Œå­èŠ‚ç‚¹ `App` æ˜¯ä¸€ä¸ª `ClassComponent`æ‰€ä»¥æ„å»º `createFiberFromElemnent` ä¹‹åä¼šè®¾ç½® `fiberTag`ï¼š

![fiberTree4 (1)](assets/fiberTree4 (1).png)

ä¹‹åå¯¹ `App`çš„ `fiber`æ‰§è¡Œ`beginWork`ï¼Œå‘½ä¸­ `ClassComponent`(åˆšè®¾ç½®çš„)ï¼Œè°ƒç”¨ `createInstance` å’Œ  `mountClassInstance` æ„å»ºç±»ç»„ä»¶å®ä¾‹å¹¶è¿æ¥ï¼Œæ‰§è¡Œ`processState` è®¡ç®— `ctor` è¿‡ç¨‹äº§ç”Ÿçš„ `state`ï¼Œä¹‹åæ‰§è¡Œä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸå‡½æ•°å¹¶é‡æ–°è®¡ç®—ï¼Œå¦‚æœè¿™ä¸ª `ClassComponent` æœ‰ `ComponentDidMount` åˆ™è®¾ç½® `update` æ ‡è®°ä½ã€‚

æœ€åè°ƒç”¨ `render` æ–¹æ³•åˆ›å»ºå­èŠ‚ç‚¹ä¼ å…¥ `reconcileChildren` åˆ›å»º `fiber`å­æ ‘ï¼š

![fiberTree5 (1)](assets/fiberTree5 (1).png)

èµ°åˆ° `div` è¿™ä¸ª `HostComponent`ï¼Œæ ¹æ®ä»–çš„ `pendingProps.children` ä¼ å…¥`reconcileChildren`æ„å»ºå­æ ‘ï¼Œç”±äº `Box`å’Œ `List`éƒ½æ˜¯å‡½æ•°ç»„ä»¶ï¼Œæ‰€ä»¥åˆå§‹ç±»å‹æ˜¯ `IndeterminateComponent`ï¼š

![fiberTree6](assets/fiberTree6.png)

`beginWork` å†æ‰§è¡Œåˆ° `Box`çš„æ—¶å€™ä»–çš„ç±»å‹ä¼šè¢«æ•²å®š `FunctionComponent`ï¼Œæ‰€ä»¥èµ° `FP`çš„æ›´æ–°æµç¨‹ï¼Œæ‰§è¡Œå‡½æ•°åˆ›å»ºå­èŠ‚ç‚¹ï¼Œç„¶å `reconcileChildrenArray` å¾—åˆ°ä¸¤ä¸ªå­èŠ‚ç‚¹ `HostComponent` çš„ `fiber`ï¼š

![fiberTree7](assets/fiberTree7.png)

> [æ³¨æ„ï¼š]()æ­¤æ—¶ `List` è¿˜æ˜¯ `IndeterminateComponent`ã€‚

åœ¨ä¹‹åç”±äº `Input` æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œ`next` ä¼šè¢«æ ‡å®š `null`ï¼Œæ‰€ä»¥å†æ‰§è¡Œ `processUnitOfWork`èµ°çš„å°±æ˜¯ `completeUnitOfWork`:

![fiberTree8 (3)](assets/fiberTree8 (3).png)

### 3.2 completeUintOfWork

å¯¹ `Input`æ‰§è¡Œ `completeUnitOfWork`ï¼Œè¿›å…¥ `completeWork` å¯¹ `HostComponent` æ‰§è¡Œæ„å»º `dom` å’Œå±æ€§åˆå§‹åŒ–é€šè¿‡ `stateNode` è¿æ¥ï¼Œç”±äº `Input` æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸éœ€è¦ç»§æ‰¿ `effect` é“¾æ¡ã€‚å¹¶ä¸”ä¼šé‡è®¾ `resetChildExpirationTime`ï¼š

![fiberTree8 (4)](assets/fiberTree8 (4).png)

ä¹‹åç”±äº `InputFiber` çš„ `sibling` ä¸æ˜¯ `null`ï¼Œæ‰€ä»¥ä¼šç»™ `nextUnitOkWork` èµ‹å€¼ `btnFiber`ï¼Œç„¶åå’Œ `inputFiber`ä¸€æ ·å†èµ°ä¸€é `beginWork`+ `completeUnitOfUnit`çš„æµç¨‹ï¼Œæ„å»º `btn` èŠ‚ç‚¹ã€‚

![fiberTree9 (1)](assets/fiberTree9 (1).png)

æ„å»ºå®Œ `btn`ï¼Œå‘ç°å…¶æ²¡æœ‰å…„å¼Ÿ `fiber`ï¼Œæ‰€ä»¥ `workProgress` å‘ä¸Šæ¸¸èµ°å»ï¼Œåˆ°äº† `BoxFiber` é‚£é‡Œï¼Œæ‰§è¡Œ` completeWork`ï¼Œç»™ `div` æ‹¼æ¥ `effect` é“¾æ¡ã€‚å› ä¸ºè¿™æ˜¯ä¸€ä¸ª `FP` æ‰€ä»¥ ` completeWork`ä¸ä¼šåšä»»ä½•äº‹ï¼š

![fiberTree10 (1)](assets/fiberTree10 (1).png)çœ‹åˆ°ä¸‹é¢è¿™å¼ å›¾ä½ å¯èƒ½æ„Ÿè§‰è¿™è·¨åº¦æœ‰ç‚¹å¤§ï¼Œä½†æ˜¯å…¶å®éƒ½æ˜¯çš„æ“ä½œï¼Œæ‰€ä»¥æˆ‘è·³è¿‡äº†ä¸€äº›éƒ¨åˆ†ï¼Œ`Box` çš„ `sibling`æ˜¯ `list`ï¼Œå…ˆå¯¹ä»–æ‰§è¡Œ `beginWork`æ„å»ºä¸¤ä¸ª `HostComponent` ï¼Œç„¶åå¯¹ç¬¬ä¸€ `li` çš„ `fiber` æ‰§è¡ŒåŒæ ·çš„æ“ä½œï¼Œä¸€ç›´åˆ°ä¸¤ä¸ª `HostText`ã€‚

ç„¶åå‘ä¸Šè¿”å›è¡”æ¥ `effect`ï¼Œæ„ç­‘ä¸¤ä¸ªæ–‡æœ¬èŠ‚ç‚¹ `love` å’Œ `you`ï¼Œä¹‹ååŒæ ·çš„å‘ä¸Šè¿”å›æ‹¼æ¥ `effect` æ„ç­‘èŠ‚ç‚¹ `li` ï¼Œä¸è¿‡è¿™é‡Œè¦å¯¹å­èŠ‚ç‚¹åšä¸€ä¸ªæ’å…¥çš„æ“ä½œã€‚æ€»ä¹‹æœ€åä¸€æ­¥ä¸€æ­¥æ‰§è¡Œåˆ° `listFiber` è¿™ä¸ª `FP`ï¼ŒåŒæ ·å› ä¸ºè¿™æ˜¯ä¸€ä¸ª `FP` æ‰€ä»¥ ` completeWork`ä¸ä¼šåšä»»ä½•äº‹ï¼š![fiberTree11 (1)](assets/fiberTree11 (1)-3827707.png)

> è¿™é‡Œæˆ‘è®²çš„è‡ªå·±éƒ½æœ‰ç‚¹æ‡µï¼Œè‡ªå·±æ¨¡æ‹Ÿä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹å§ã€‚

ç„¶ååˆ°äº† `divFiber` åš `completeWork`æ„å»º `dom` æ·»åŠ å­èŠ‚ç‚¹è®¾ç½®åˆå§‹å±æ€§ï¼Œæ›´æ–°çˆ¶èŠ‚ç‚¹çš„ `effectChain`(è¿™é‡Œçˆ¶èŠ‚ç‚¹çš„ `chain`)å’Œä»–è‡ªå·±ä¸€æ ·ï¼Œåˆ°è¿™é‡Œæˆ‘ä»¬çš„ `domTree`å°±æ„å»ºå®Œæˆäº†ï¼š

![fiberTree12](assets/fiberTree12.png)

ç»ˆäºåˆ°äº† `AppFiber`ï¼Œå¯¹ä¸€ä¸ª` ComponentFiber`æ‰§è¡Œ `completeWork` ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿï¼Œæ‰€ä»¥è¿™é‡Œåªä¼šç»™çˆ¶èŠ‚ç‚¹è®¾ç½® `effectChain`ï¼š

![fiberTree13 (1)](assets/fiberTree13 (1).png)

æœ€ååˆ°äº† `HostRootFiber` ä»–çš„ `returnFIber`æ˜¯ `null`ï¼Œæ‰€ä»¥ `completeUnitOfWork`è¿”å› `null`ï¼Œ`performUnitOfWork`æ‰§è¡Œå®Œæˆï¼Œæ­¤æ—¶ `nextUnitOfWork===null`(å³ä¸‹è§’)ï¼Œæ‰€ä»¥ `workLoop` ä¼šé€€å‡º ï¼Œ`renderRoot`é‡Œ `workLoop`è¿™éƒ¨åˆ†å°±ç»“æŸäº†ï¼ï¼ï¼ï¼

```ts
function workLoop(isYieldy) {
  if (!isYieldy) {
    // Flush work without yielding
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    // Flush asynchronous work until the deadline runs out of time.
    while (nextUnitOfWork !== null && !shouldYield()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
```

### 3.3 unwindWork

å›åˆ°`beginWork`æ‰§è¡Œåˆ° `Box`çš„æ—¶å€™ï¼Œå¦‚æœå‘ç”Ÿäº†é”™è¯¯ï¼Œè¿™ä¸ªæ—¶å€™é”™è¯¯æŠ›å‡ºå°±èµ°åˆ° `throwExpection`çš„éƒ¨åˆ†ï¼š

![fiberTree14 (2)](assets/fiberTree14 (2).png)

è¿™ä¸ªå‡½æ•°ä¼šä¸€ç›´å‘ä¸Šæ‰¾åˆ°ä¸€ä¸ªèƒ½èƒ½å¤„ç†é”™è¯¯çš„ç»„ä»¶(`ClassComponent`æˆ–è€…`HostRoot`)ï¼Œæ¯”å¦‚æ˜¯ä¸€ä¸ª `ClassComponent`å¹¶ä¸”æœ‰ `getDervicedStateFromError`æˆ–è€…`componentDidCatch` è¿™æ ·çš„ç”Ÿå‘½å‘¨æœŸå‡½æ•°ã€‚è¿™ä¸ªæ—¶å€™ä¼šç»™ä»–æ·»åŠ  `ShouldCapture` æ ‡è®°ä½ç„¶åæ·»åŠ  `CaptureUpdate`ï¼š

![fiberTree15](assets/fiberTree15.png)

`throwExpection`æ‰§è¡Œå®Œæˆä¹‹åï¼Œå°±ä¼šåœ¨å‡ºé”™è¯¯çš„èŠ‚ç‚¹ä¸Šç»§ç»­æ‰§è¡Œ `completeUnitOfWork`ï¼Œé‡Œé¢å¾ªç¯è¿™å›æ¯æ¬¡éƒ½ä¼šæ‰§è¡Œ `unwindWork` ï¼Œå¹¶ä¸”æŠŠçˆ¶çº§èŠ‚ç‚¹æ ‡è®°ä½ `InComplete`ï¼Œä¸è¿‡ `unwindWork`æ²¡éå†åˆ° `ClassComponent` æˆ–è€… `HostRoot`å°±ä¸ä¼šæœ‰ä»»ä½•ä½œç”¨ï¼Œè€Œå¯¹` ClassComponent`æˆ–è€…` HostRoot`ä¼šæ ‡è®°`DidCapture`ç„¶åå–æ¶ˆ `shouldCapture`ï¼š

![fiberTree16](assets/fiberTree16.png)



è¿™ä¸ªæ•è·é”™è¯¯çš„ç»„ä»¶çš„ `fiber`ä¼šæ‰§è¡Œ `next.effectTag &= HostEffectMask;` æ¸…ç©ºé™¤äº†` DidCapture` æ‰€æœ‰æ ‡è®°ä½ï¼Œç„¶å `completeUnitOfWork` ä¼šè·³å‡ºï¼Œ`workLoop` åœ¨è¿™ä¸ªç»„ä»¶ `fiber` ç»§ç»­æ‰§è¡Œ `beginWork`.....

è¿™æ¬¡ `beginWork` ä¼šæ‰§è¡Œåˆšæ‰æ¨å…¥çš„é”™è¯¯å¤„ç†ç”Ÿå‘½å‘¨æœŸå›è°ƒï¼Œç„¶åå¸è½½å…¨éƒ¨èŠ‚ç‚¹ï¼š

![fiberTree17](assets/fiberTree17.png)

> [å°è´´å£«ï¼š]()`unwindWork`çš„è¿‡ç¨‹ä¸­ä¼šæ¸…ç©ºç»è¿‡èŠ‚ç‚¹çš„æ‰€æœ‰å‰¯ä½œç”¨ï¼Œä¸Šé¢æ²¡æœ‰ä½“ç°ï¼Œè®°åœ¨å¿ƒé‡Œå°±å¥½ã€‚