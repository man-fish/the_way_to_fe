#  beginWork

[react-reconciler/src/ReactFiberScheduler.js]()

```ts
function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;
  let next = beginWork(current, workInProgress, nextRenderExpirationTime);
  return next;
}
```

> ä¸ºä»€ä¹ˆ `current` åœ¨è¿™é‡Œè¢«å½“åš `alternate`ï¼Ÿ
>
> å› ä¸ºæ¯æ¬¡æ›´æ–°å®Œä¹‹å `current` å’Œ `alternate` éƒ½è¦äº¤æ¢ä½ç½®ã€‚

<img src="assets/image-20210912110418440.png" alt="image-20210912110418440" style="zoom:40%;" />

è€è§„çŸ©å…ˆå›é¡¾ä¸€ä¸‹å…¥å£å‡½æ•°çš„è°ƒç”¨(åˆ é™¤äº†å¾ˆå¤šé€»è¾‘)æ¥æ‰¿ä¸Šå¯ä¸‹ï¼Œ`beginWork`ç”¨äºè®¡ç®—å‡ºå½“å‰ä»»åŠ¡å•å…ƒçš„ `fiber`.è¿™ä¸ªå‡½æ•°ä¼šæ ¹æ®å„ç§ä¸åŒçš„ `ElementType` æ¥ä½¿ç”¨ä¸åŒçš„ä¼˜åŒ–å’Œç”Ÿæˆå­çº§ `Fiber` ç­–ç•¥ï¼ŒåŒæ—¶è¿˜ä¼šè®¾ç½®ç”Ÿæˆè¿‡ç¨‹ä¸­äº§ç”Ÿçš„å‰¯ä½œç”¨æ ‡è®°ä½ï¼š

è¿™ä¸ªå…¥å£å‡½æ•°çš„æ‰§è¡Œåˆ†ä¸¤ç§æƒ…å†µï¼š

+ ç¬¬ä¸€ç§æƒ…å†µå°±æ˜¯å½“å‰çš„ `fiber` æ²¡æœ‰ä»»ä½•çš„æ›´æ–°ä»»åŠ¡ï¼š

  ```ts
  if (current !== null) 
      if (
  			oldProps === newProps &&
        !hasLegacyContextChanged() &&
        (updateExpirationTime === NoWork ||
          updateExpirationTime > renderExpirationTime)
       )
  ```

  è¿™ä¸ªæ—¶å€™ä¼šæ‰§è¡Œä¸€äº›å…³äº `context` çš„æ“ä½œï¼Œç„¶åæ‰§è¡Œ `bailoutOnAlreadyFinishedWork`ï¼Œè¿™ä¸ªå‡½æ•°ä¼šå†æ¬¡åˆ¤æ–­å­èŠ‚ç‚¹æ˜¯å¦æœ‰æ›´æ–°ä»»åŠ¡ï¼Œæ²¡æœ‰ä»–å°±è¿”å› `null` æ¥åœæ­¢å‘ä¸‹éå†ï¼Œå¦‚æœå­èŠ‚ç‚¹æœ‰ä»»åŠ¡å®ƒä¼šè·³è¿‡å½“å‰èŠ‚ç‚¹ã€‚

  ```ts
  function bailoutOnAlreadyFinishedWork(
    current: Fiber | null,
    workInProgress: Fiber,
    renderExpirationTime: ExpirationTime,
  ): Fiber | null {
    // Check if the children have any pending work.
    const childExpirationTime = workInProgress.childExpirationTime;
    if (
      childExpirationTime === NoWork ||
      childExpirationTime > renderExpirationTime
    ) {
      return null;
    } else {
      cloneChildFibers(current, workInProgress);
      return workInProgress.child;
    }
  }
  ```

+ å¦‚æœ `fiber` ä¸Šæœ‰æ›´æ–°ä»»åŠ¡ï¼Œé¦–å…ˆå®ƒä¼šæ ‡è®° `workInProgress.expirationTime = NoWork;` æ¸…ç©ºèŠ‚ç‚¹çš„ `expirationTime`ã€‚ç„¶åå¯¹ä¸ä¸åŒçš„ç»„ä»¶æ‰§è¡Œä¸åŒçš„`fiber` æ›´æ–°|æ„å»ºæ–¹æ¡ˆã€‚

[react-reconciler/src/ReactFiberBeginWork.js]()

```ts
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderExpirationTime: ExpirationTime,
): Fiber | null {
  const updateExpirationTime = workInProgress.expirationTime;

  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    if (
      oldProps === newProps &&
      !hasLegacyContextChanged() &&
      (updateExpirationTime === NoWork ||
        updateExpirationTime > renderExpirationTime)
    ) {
      // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.
      switch (workInProgress.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress);
          resetHydrationState();
          break;
        case HostComponent:
          pushHostContext(workInProgress);
          break;
        case ClassComponent: {
          const Component = workInProgress.type;
          // ComponentType, if host element it will be a string likes 'div'
          if (isLegacyContextProvider(Component)) {
            pushLegacyContextProvider(workInProgress);
          }
          break;
        }
        case HostPortal:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo,
          );
          break;
        case ContextProvider: {
          const newValue = workInProgress.memoizedProps.value;
          pushProvider(workInProgress, newValue);
          break;
        }
        case Profiler:
          if (enableProfilerTimer) {
            workInProgress.effectTag |= Update;
          }
          break;
        case SuspenseComponent: {
          const state: SuspenseState | null = workInProgress.memoizedState;
          const didTimeout = state !== null && state.didTimeout;
          if (didTimeout) {
            // If this boundary is currently timed out, we need to decide
            // whether to retry the primary children, or to skip over it and
            // go straight to the fallback. Check the priority of the primary
            // child fragment.
            const primaryChildFragment: Fiber = (workInProgress.child: any);
            const primaryChildExpirationTime =
              primaryChildFragment.childExpirationTime;
            if (
              primaryChildExpirationTime !== NoWork &&
              primaryChildExpirationTime <= renderExpirationTime
            ) {
              // The primary children have pending work. Use the normal path
              // to attempt to render the primary children again.
              return updateSuspenseComponent(
                current,
                workInProgress,
                renderExpirationTime,
              );
            } else {
              // The primary children do not have pending work with sufficient
              // priority. Bailout.
              const child = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress,
                renderExpirationTime,
              );
              if (child !== null) {
                // The fallback children have pending work. Skip over the
                // primary children and work on the fallback.
                return child.sibling;
              } else {
                return null;
              }
            }
          }
          break;
        }
      }
      return bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderExpirationTime,
      );
    }
  }

  // Before entering the begin phase, clear the expiration time.
  workInProgress.expirationTime = NoWork;

  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      const elementType = workInProgress.elementType;
      return mountIndeterminateComponent(
        current,
        workInProgress,
        elementType,
        renderExpirationTime,
      );
    }
    case LazyComponent: {
      const elementType = workInProgress.elementType;
      return mountLazyComponent(
        current,
        workInProgress,
        elementType,
        updateExpirationTime,
        renderExpirationTime,
      );
    }
    case FunctionComponent: {
      const Component = workInProgress.type;
      // ComponentType, if host element it will be a string likes 'div'
      const unresolvedProps = workInProgress.pendingProps;
      // future props which has not been resolved
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
          // SuspenseComponent å¼‚æ­¥éœ€è¦resolve
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderExpirationTime,
      );
    }
    case ClassComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderExpirationTime,
      );
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderExpirationTime);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderExpirationTime);
    case HostText:
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      return updateSuspenseComponent(
        current,
        workInProgress,
        renderExpirationTime,
      );
    case HostPortal:
      return updatePortalComponent(
        current,
        workInProgress,
        renderExpirationTime,
      );
    case ForwardRef: {
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === type
          ? unresolvedProps
          : resolveDefaultProps(type, unresolvedProps);
      return updateForwardRef(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderExpirationTime,
      );
    }
    case Fragment:
      return updateFragment(current, workInProgress, renderExpirationTime);
    case Mode:
      return updateMode(current, workInProgress, renderExpirationTime);
    case Profiler:
      return updateProfiler(current, workInProgress, renderExpirationTime);
    case ContextProvider:
      return updateContextProvider(
        current,
        workInProgress,
        renderExpirationTime,
      );
    case ContextConsumer:
      return updateContextConsumer(
        current,
        workInProgress,
        renderExpirationTime,
      );
    case MemoComponent: {
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps = resolveDefaultProps(type.type, unresolvedProps);
      return updateMemoComponent(
        current,
        workInProgress,
        type,
        resolvedProps,
        updateExpirationTime,
        renderExpirationTime,
      );
    }
    case SimpleMemoComponent: {
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        updateExpirationTime,
        renderExpirationTime,
      );
    }
    case IncompleteClassComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return mountIncompleteClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderExpirationTime,
      );
    }
    default:
      invariant(
        false,
        'Unknown unit of work tag. This error is likely caused by a bug in ' +
          'React. Please file an issue.',
      );
  }
}
```

> [å°è´´å£«ï¼š]()è§£è¯»å®Œè¿™å‡ ç§æƒ…å†µçš„å¤„ç†æˆ‘å‘ç°ï¼Œ`FunctionComponent` å’Œ `ClassComponent` éƒ½ä¸ä¼šæ¸²æŸ“ `props.children` è€Œæ˜¯ä¼šæ¸²æŸ“ `return`è¿”å›çš„æˆ–è€… `render` è¿”å›çš„å†…å®¹ã€‚

## 1. FunctionComponent

[react-reconciler/src/ReactFiberBeginWork.js]()

```ts
// Before entering the begin phase, clear the expiration time.
workInProgress.expirationTime = NoWork;

switch (workInProgress.tag) {
  case FunctionComponent: {
    const Component = workInProgress.type;
    // ComponentType, if host element it will be a string likes 'div'
    const unresolvedProps = workInProgress.pendingProps;
    // future props which has not been resolved
    const resolvedProps =
         workInProgress.elementType === Component
    			? unresolvedProps
    			: resolveDefaultProps(Component, unresolvedProps);
    // SuspenseComponent å¼‚æ­¥éœ€è¦resolve
    return updateFunctionComponent(
      current,
      workInProgress,
      Component,
      resolvedProps,
      renderExpirationTime,
    );
  }
}
```

å…ˆä»æœ€ç®€å•çš„ `FunctionComponent`å¼€å§‹åˆ†æä¸€ä¸‹ `fiber` æ„å»ºçš„æµç¨‹ï¼Œé¦–å…ˆ `Component = workInProgress.type;` å…¶å®å°±æ˜¯è·å–å‡½æ•°ç»„ä»¶çš„é‚£ä¸ªå‡½æ•°ï¼Œç„¶åå£°æ˜ä¸¤ä¸ªå±æ€§ `unresolvedProps` å’Œ `resolvedProps` åˆ†åˆ«ä»£è¡¨æœªè®¡ç®—å’Œè®¡ç®—å®Œæˆçš„ `prop`ï¼Œç„¶åè°ƒç”¨ `updateFunctionComponent`ã€‚

### 1.1 updateFunctionComponent

[react-reconciler/src/ReactFiberBeginWork.js]()

```ts
// åˆ é™¤äº† context ä»¥åŠ DEV ç›¸å…³ä»£ç ï¼š
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps: any,
  renderExpirationTime,
) {
  let nextChildren = Component(nextProps, context); // è®¡ç®—å‡ºå­èŠ‚ç‚¹

  // React DevTools reads this flag. åªæ˜¯ç”¨æ¥è¡¨æ˜è¿™ä¸ªç»„ä»¶æœ‰è¢«æ›´æ–°
  workInProgress.effectTag |= PerformedWork;
  reconcileChildren( 
    // component(ReactElement) -> Children Fibers
    current,
    workInProgress,
    nextChildren,
    renderExpirationTime,
  );
  return workInProgress.child;
}
```

è¿™ä¸ªå‡½æ•°çš„æµç¨‹ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯è®¡ç®—å‡ºå­èŠ‚ç‚¹(æ‰§è¡Œä¸€ä¸‹å‡½æ•°ç»„ä»¶)ï¼Œç„¶åæ”¹å˜æ ‡è¯†ä½ï¼Œè°ƒç”¨ `reconcileChildren`ï¼Œå°†è®¡ç®—å‡ºçš„å­èŠ‚ç‚¹æ˜ å°„åˆ°å­ `fiber` å¹¶è¿”å›è®¡ç®—å‡ºçš„å­ `fiber`ã€‚

### 1.2 reconcileChildren

[react-reconciler/src/ReactFiberBeginWork.js]()

```ts
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderExpirationTime: ExpirationTime,
) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderExpirationTime,
    );
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderExpirationTime,
    );
  }
}
```

`reconcileChildren` æ ¹æ® `current`æ˜¯å¦ä¸º `null`(`fiber`æ˜¯å¦é¦–æ¬¡æ›´æ–°)ï¼Œè°ƒç”¨ `mountChildFibers` æˆ–è€… `reconcileChildFibers` ç”Ÿæˆå­ `fiber` å¹¶ä¸”æŒ‚è½½ã€‚

## 2. ChildReconciler

[react-reconciler/src/ReactChildFiber.js]()

```ts
export const reconcileChildFibers = ChildReconciler(true);
export const mountChildFibers = ChildReconciler(false);
```

è¿™ä¸ªå‡½æ•°æ˜¯æœ¬ç‰‡çš„é‡å¤´æˆï¼Œæ˜¯çœŸæ­£è´Ÿè´£ `fiber` èŠ‚ç‚¹è®¡ç®—(æ–°å»ºã€æ›´æ–°ã€åˆ é™¤ã€`etc`)çš„éƒ¨åˆ†ï¼Œé€šè¿‡æ ‡è¯†ä½è¡ç”Ÿå‡º `reconcileChildFibers` å’Œ `mountChildFibers` ä¸¤ä¸ªå‡½æ•°ä½œä¸ºå¯¹å¤–æš´éœ²çš„æ¥å£ã€‚

[react-reconciler/src/ReactChildFiber.js]()

```ts
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild()	// ok
  function deleteRemainingChildren()	// ok
  function mapRemainingChildren()
  function useFiber() // ok
  function placeChild() // done
  function placeSingleChild() 
  function updateTextNode() // done
  function updateElement() // done
  function updatePortal()
  function updateFragment() // done
  function createChild() // done
  function updateSlot() // done
  function updateFromMap() // done
  function warnOnInvalidKey()
  function reconcileChildrenArray() // done
  function reconcileChildrenIterator() // done
  function reconcileSingleTextNode() // ok
  function reconcileSingleElement() // ok
  function reconcileSinglePortal()
  function reconcileChildFibers() // ok
  return reconcileChildFibers;
}
```

å¯¹äºè¿™ä¸ªå¤§çš„é—­åŒ…ï¼Œå®ƒçš„å‚æ•°è¦æ³¨æ„ä¸€ä¸‹ï¼š`shouldTrackSideEffects`ï¼Œç¬¬ä¸€æ¬¡æ›´æ–°çš„æ—¶å€™ï¼Œå­ `fiber` è¿˜æ²¡æœ‰æ„å»ºï¼Œæ‰€ä»¥æœ‰ä¸€äº›å‰¯ä½œç”¨ä¸ä¼šäº§ç”Ÿï¼Œ`shouldTrackSideEffects` ä¸º `false`ã€‚

å› ä¸ºè´Ÿè´£çš„ä»»åŠ¡å¤ªå¤šï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°å®åœ¨æ˜¯åˆè‡­åˆé•¿(è®¾è®¡å¤ªå¤šå­å‡½æ•°é—­åŒ…)ï¼Œä¸è¿‡è¿”å›å€¼æ¸…æ™°æ˜äº†ï¼Œå°±æ˜¯å‡½æ•° `reconcileChildFibers` æ‰€ä»¥å…ˆä»è¿™ä¸ªå‡½æ•°å…¥æ‰‹çœ‹çœ‹ï¼š

### 2.1 reconcileChildFibers

ä»£ç å¤ªé•¿äº†æˆ‘ä»¬æ‹†å¼€æ¥çœ‹ï¼Œç¬¬ä¸€æ­¥è®¡ç®—å‡º `isUnkeyedTopLevelFragment`ï¼Œç”¨äºåˆ¤æ–­æ–°å…ƒç´ çš„é¡¶çº§èŠ‚ç‚¹æ˜¯ä¸æ˜¯ä¸€ä¸ª `Fragment` ç±»å‹ï¼Œå¦‚æœè¯´æ˜¯é‚£ä¹ˆå°†å…¶å­èŠ‚ç‚¹ä½œä¸ºæ–°çš„èŠ‚ç‚¹ `newChild = newChild.props.children;`ï¼š

[react-reconciler/src/ReactChildFiber.js]()

```ts
  function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    expirationTime: ExpirationTime,
  ): Fiber | null {
    const isUnkeyedTopLevelFragment =
      typeof newChild === 'object' &&
      newChild !== null &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      newChild.key === null;
      // åˆ¤æ–­é¡¶å±‚èŠ‚ç‚¹æ˜¯ä¸æ˜¯ä¸€ä¸ª Fragment èŠ‚ç‚¹ï¼Œ <></>
    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
      // ç›´æ¥è·³è¿‡ Fragment
    }
// ...
```

ä¹‹ååˆ¤æ–­ `newChild` æ˜¯ä¸æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¦‚æœæ˜¯å¯¹è±¡é‚£ä¸€èˆ¬æ˜¯ç”± `React.createElement` æˆ–è€… `createPortal` ç­‰ç­‰å†…ç½®å‡½æ•°æˆ–è€… `jsx` è§£æå‡ºæ¥çš„å¯¹è±¡ `$$typeof` ä¸€èˆ¬ä¸º `REACT_ELEMENT_TYPE`æˆ–è€…å…¶ä»–ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¼šèµ° `reconcileSingleElement` æˆ–è€… `placeSingleChild`ã€‚

```ts
// ...
    // Handle object types
    const isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
        case REACT_PORTAL_TYPE:
          return placeSingleChild(
            reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
      }
    }
// ...
```

å†…å»ºå¯¹è±¡è§£æå®Œä¹‹åå°±è¿˜å‰©ä¸‹é¢å‡ ç§æƒ…å†µï¼š

+ `newChild` æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè°ƒç”¨ `reconcileChildrenArray`ã€‚
+ `newChild` æ˜¯ä¸€ä¸ª æ–‡æœ¬èŠ‚ç‚¹ï¼Œè°ƒç”¨ `reconcileSingleTextNode`ã€‚
+ `newChild`æ˜¯ä¸€ä¸ªæœ‰éå†å™¨æ¥å£çš„å¯¹è±¡ï¼Œè°ƒç”¨ `reconcileChildrenIterator`ã€‚

å¦‚æœä¸Šé¢è¿™äº›åˆ¤æ–­éƒ½æ²¡å‘½ä¸­ï¼ŒåŒæ—¶å…¶è¿˜æ˜¯ä¸€ä¸ªå¯¹è±¡é‚£è¯´æ˜ä¼ å…¥å‚æ•°ä¸åˆæ³•ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯ã€‚

```ts
//...
		if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(
        reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          '' + newChild,
          expirationTime,
        ),
      );
    }

    if (isArray(newChild)) {
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }
//...
```

å¦‚æœè¯´æœ€åå‘ç° `newChild` æ˜¯ `undefined` ï¼Œè¯´æ˜ç»„ä»¶æ²¡æœ‰è¿”å›ï¼Œè¿™ä¸ªæ—¶å€™ `react` ä¼šåšä¸€äº›æç¤ºï¼Œä½†æ˜¯ä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œå¹¶ä¸”ä¼šè°ƒç”¨ `deleteRemainingChildren` åˆ é™¤å­æ ‘ã€‚

```ts
//...
		if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      switch (returnFiber.tag) {
        case ClassComponent: {
          // do some report on dev mode
        }

        case FunctionComponent: {
          const Component = returnFiber.type;
          invariant(
            false,
            '...',
            Component.displayName || Component.name || 'Component',
          );
        }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }
```

### 2.2 reconcileSingleElement

å…ˆä»åˆ†æ”¯çš„ç¬¬ä¸€ä¸­æƒ…å†µï¼Œåªæœ‰ä¸€ä¸ªå­å…ƒç´ å¼€å§‹ï¼Œè¿™ä¸ªå…ƒç´ é¦–å…ˆæ˜¯ä¸€ä¸ªç®€å•çš„ `ReactElement` (å¯èƒ½æ˜¯å®¿ä¸»èŠ‚ç‚¹)ï¼Œè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹åæˆ‘ä»¬ä¼ å…¥å››ä¸ªå‚æ•°ï¼š

+ `returnFiber`ï¼š å½“å‰ `fiber` èŠ‚ç‚¹ï¼Œå³è°ƒç”¨ `ChildReconciler` çš„èŠ‚ç‚¹ã€‚
+ `currentFirstChild`ï¼šâ˜ï¸çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œå¯èƒ½æ˜¯ `null`(é¦–æ¬¡æ¸²æŸ“)ã€‚
+ `element`ï¼šå­ `fiber` å¯¹åº”çš„ `ReactElement`ã€‚
+ `expirationTime`ï¼šä¼ å®¶å®ã€‚

è¿™ä¸ªå‡½æ•°å¯ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œ`currentFirstChild` ä¸æ˜¯ `null`ï¼Œè¯´æ˜æ˜¯æ›´æ–° `fiber` é‚£ä¹ˆå¾ˆæœ‰å¯èƒ½æŸä¸ªè€çš„å­ `fiber` å’Œæ–°çš„ `ReactElement`çš„ `key` ç›¸åŒï¼Œå¹¶ä¸”ä¸¤è€…ç±»å‹(`type`)ç›¸åŒï¼Œæˆ–è€…ä¸¤è€…çš„ç±»å‹éƒ½æ˜¯ `Fragment` ã€‚

æ­¤æ—¶æ ¹æ® `diff` ç®—æ³•è§„åˆ™ï¼Œè¿™ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¯ä»¥çœ‹ä½œç›¸åŒèŠ‚ç‚¹çš„ã€‚

æ‰€ä»¥æ­¤æ—¶æˆ‘ä»¬è¦éå† `child`  æ‰¾åˆ°å¯èƒ½å­˜åœ¨çš„ç›¸åŒèŠ‚ç‚¹ï¼Œæ‰¾åˆ°äº†å°±å¯ä»¥è°ƒç”¨ `useFiber` ä¿ç•™æ­¤èŠ‚ç‚¹åšä¸€äº›å¿…è¦çš„æ›´æ–°ï¼Œç„¶åè°ƒç”¨ `deleteRemainingChildren` åˆ é™¤å…¶å…„å¼ŸèŠ‚ç‚¹ï¼Œå› ä¸º `reconcileSingleElement` è¡¨ç¤ºåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚

ä¸è¿‡å¦‚æœæˆ‘ä»¬å‘ç° `key` ç›¸åŒçš„èŠ‚ç‚¹çš„ `type` å’Œ `elementType` ä¸ç›¸åŒï¼Œæ­¤æ—¶è¡¨ç¤ºä¸å¯èƒ½å­˜åœ¨å¯å¤ç”¨èŠ‚ç‚¹ï¼Œæ‰€ä»¥å…¨éƒ¨åˆ æ‰é‡å»ºï¼š`deleteRemainingChildren`ã€‚

```ts
  function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement,
    expirationTime: ExpirationTime,
  ): Fiber {
    const key = element.key;
    // key
    let child = currentFirstChild;
    
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (
          child.tag === Fragment
            ? element.type === REACT_FRAGMENT_TYPE
            : child.elementType === element.type
        ) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(
            child,
            element.type === REACT_FRAGMENT_TYPE
              ? element.props.children
              : element.props,
            expirationTime,
          );
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
// ...
```

æ²¡æœ‰èµ°å¤ç”¨çš„æƒ…å†µå°±åªèƒ½æ–°å»ºèŠ‚ç‚¹äº†ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š

+ `Fragment`ï¼šè°ƒç”¨ `createFiberFromFragment`ã€‚
+ `Element`ï¼šè°ƒç”¨ `createFiberFromElement`ã€‚

ä¸¤è€…éƒ½è¦è¡”æ¥ `return` é“¾æ¡ï¼Œ`createFiberFromElement` è¿˜è¦å¯¹ `ref` åšé¢å¤–çš„æ“ä½œã€‚

```ts
//...
		if (element.type === REACT_FRAGMENT_TYPE) {
      const created = createFiberFromFragment(
        element.props.children,
        returnFiber.mode,
        expirationTime,
        element.key,
      );
      created.return = returnFiber;
      return created;
    } else {
      const created = createFiberFromElement(
        element,
        returnFiber.mode,
        expirationTime,
      );
      created.ref = coerceRef(returnFiber, currentFirstChild, element);
      created.return = returnFiber;
      return created;
    }
  }
```

#### 2.2.1 deleteChild

è¿™é‡Œç¢°å·§ç”¨åˆ°äº† `deleteChild`(åŒæ ·æ˜¯`ChildReconciler`çš„å­å‡½æ•°)é‚£å°±æ¥è®²è§£ä¸€ä¸‹ï¼Œè¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯æ›´æ”¹äº†è¦åˆ é™¤ `fiber` çš„ `effect chain`ï¼Œå°†è¦åˆ é™¤çš„ `fiber` æ·»åŠ è¿›å»å¹¶ä¸”æ ‡è®° `effectTag` ä¸º `Deletion`ï¼Œåšä¸€ä¸ªä¼ªåˆ é™¤ï¼Œæœ€åæ‰§è¡Œåœ¨ `commit` é˜¶æ®µã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯å¯¹äº `Deletetion` çš„æ ‡è®°è¦ç›´æ¥æ·»åŠ å¯¹åº” `fiber` åˆ° `effectChain`ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨ `completeWork` é˜¶æ®µä¼šéå†æ–°çš„ `fiberTree` æ¥æ”¶é›† `effectTag`æ„é€  `effectChain`ï¼Œè€Œ `Deletion` å­˜åœ¨äºè€çš„`fiberTree`ä¸Šæ‹¿ä¸åˆ°ï¼Œæ‰€ä»¥è¿™é‡Œè¦æ‰‹åŠ¨æ·»åŠ ã€‚

```ts
  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    const last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }
```

> è¿™ä¸ª `effect` æ˜¯ä½œç”¨åœ¨ `current` ä¸Šçš„ï¼Œæ‰€ä»¥ä¸å† `completeWork` é‚£é‡Œæ·»åŠ ã€‚

#### 2.2.2 deleteRemainingChildren

å°±æ˜¯å¯¹ `deleteChild` åšä¸€ä¸ªè¿­ä»£ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼š

```ts
  function deleteRemainingChildren(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
  ): null {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
```

#### 2.2.3 useFiber

`useFiber` æ ¹æ®åŸæœ¬å¯å¤ç”¨çš„ `fiber(current)` æ„å»ºä¸€ä¸ª `WIP`ï¼Œå¹¶ä¸”é‡ç½®ä»–çš„ `sibling`ï¼š

```ts
  function useFiber(
    fiber: Fiber,
    pendingProps: mixed,
    expirationTime: ExpirationTime,
  ): Fiber {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    const clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
```

> `createWorkInProgress` å’Œ `createFiberFromElement` è¿™ç§å…³äº `fiber` çš„å‡½æ•°ï¼Œåœ¨ `fiber` é‚£ç« è®²è§£ã€‚

### 2.3 reconcileSingleTextNode

å¦‚æœè¯´ `newChild` æ˜¯ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ï¼Œé‚£å°±ä¼šèµ°è¿™ä¸ªå…¥å£ï¼ŒåŒæ ·æ˜¯ä¸€ä¸ªå¤ç”¨å’Œæ–°å»ºçš„è¿‡ç¨‹ï¼Œåªæ˜¯è°ƒç”¨ `ReactFiber` æä¾›çš„ `API` ä¸åŒï¼š

```ts
  function reconcileSingleTextNode(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    textContent: string,
    expirationTime: ExpirationTime,
  ): Fiber {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      const existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    const created = createFiberFromText(
      textContent,
      returnFiber.mode,
      expirationTime,
    );
    created.return = returnFiber;
    return created;
  }
```

### 2.4 reconcileChildrenArray

`reconcileChildrenArray` å¯¹åº” `newChildren` æ˜¯ä¸€ä¸ª `Array` çš„æƒ…å†µï¼Œè¿™ç§æƒ…å†µä¸‹æ¶‰åŠåˆ°ä¸¤ä¸ªæ•°ç»„çš„ `diff`æ¯”è¾ƒï¼Œ`react`ä½¿ç”¨äº†ä¸€ç§ç®—æ³•å°½é‡åšåˆ°æœ€å°çš„æ—¶é—´å¤æ‚åº¦ï¼š

#### 2.4.1 ç¬¬ä¸€æ¬¡å¾ªç¯

ç¬¬ä¸€ä¸ªå¾ªç¯é¡ºåºéå† `oldFiber` å’Œ `newChildren[newIdx]`ï¼Œéå†è¿‡ç¨‹åˆ†ä¸ºä¹±åºå’Œæ²¡ä¹±åºä¸¤ç§æƒ…å†µï¼š

+ ä¸€æ—¦é‡åˆ°ä¹±åºèŠ‚ç‚¹ï¼Œè¯´æ˜å¯èƒ½æ“ä½œè€… `hack`äº† `fiberTree` å¯¼è‡´ `oldFiber`çš„ `index`ä¹±åºäº†ï¼Œæ­¤æ—¶è®¾ç½® `oldFiber` ä¸º `null`ï¼Œè°ƒç”¨ `updateSlot` åˆ›å»º `newFiber` çš„ç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯ `null`ï¼Œé‚£ä¹ˆåŸºæœ¬ä¸Š `updateSlot` è¿”å›çš„  `newFiber` éƒ½æ˜¯ `null`ï¼Œæ­¤æ—¶ `oldFiber` å½’ä½è·³å‡ºå¾ªç¯ã€‚

+ å¦‚æœæ²¡é‡åˆ°ä¹±åºèŠ‚ç‚¹ï¼Œé‚£åœ¨ `updateSlot` ä¸­ä¼šè¿›è¡Œ `key` çš„æ¯”è¾ƒï¼Œå¦‚æœ `key` ç›¸åŒåœ¨é€‰ç”¨ä¸åŒçš„ç­–ç•¥æ¯”è¾ƒ `tag`(è¯¦è§ `updateSlot`)ï¼Œæ€»ä¹‹å‰åèŠ‚ç‚¹ `key` ç›¸åŒå°±ä¸€å®šä¸ä¼šè¿”å› `null` ä¸ä¼šè·³å‡ºå¾ªç¯ï¼š

  + `tag` ç›¸åŒé‚£ `updateSlot` è°ƒç”¨çš„å­å‡½æ•°å¯èƒ½å¤ç”¨äº†è¿™ä¸ª `oldFiber`ã€‚

  + `tag` ä¸ç›¸åŒï¼Œ`newFiber` æ˜¯æ–°å»ºçš„ï¼Œæ²¡å¤ç”¨ `oldFiber` è¿™ä¸ªæ—¶å€™èµ°åˆ°è¿™ä¸ªåˆ¤æ–­ï¼š

    ```ts
    if (shouldTrackSideEffects&& (oldFiber && newFiber.alternate === null)
    ```

    åœ¨ `shouldTrackSideEffects` çš„æƒ…å†µä¸‹(éç¬¬ä¸€æ¬¡åˆ›å»º)è¦åˆ é™¤ `oldFiber`ã€‚

+ ç°åœ¨æ–°èŠ‚ç‚¹ `newFiber` å·²ç»åˆ›å»ºï¼Œè¯¥åˆ é™¤çš„ `oldFiber` å·²ç»æ ‡è®°ï¼Œæ­¤æ—¶è¦è°ƒç”¨ `placeChild` æ”¾ç½®èŠ‚ç‚¹ã€‚

+ ä¹‹ååœ¨ `resultingFirstChild` æ”¾ç½® `newFiber`ã€‚

```ts
  function reconcileChildrenArray(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChildren: Array<*>,
    expirationTime: ExpirationTime,
  ): Fiber | null {
    let oldFiber = currentFirstChild; // null in first render
    let nextOldFiber = null;
 
    let newIdx = 0;
		let lastPlacedIndex = 0;
      
    let resultingFirstChild: Fiber | null = null;
    let previousNewFiber: Fiber | null = null;
    
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      // é¡ºåºéå†
      if (oldFiber.index > newIdx) { // ä¹±åºäº†
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        expirationTime,
      );
      if (newFiber === null) {
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
// ....
```

**æ —å­ ğŸŒ°**

æ¥çœ‹ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼Œé¦–å…ˆç¬¬ä¸€æ¬¡æ¯”è¾ƒèŠ‚ç‚¹ï¼Œ`key` å’Œ `tag` éƒ½ç›¸åŒï¼Œæ‰€ä»¥å¤ç”¨èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ›´æ–° `previousNewFiber` ä¸ºè¿™ä¸ª`newFiber` ï¼Œç„¶åè®¾ç½® `newFiber` ä¸º `resultFisrtChild` çš„å¤´èŠ‚ç‚¹ï¼Œæ›´æ–° ` lastPlaceElement=0`ã€‚

<img src="assets/fiberDiff0.png" alt="fiberDiff0" style="zoom:50%;" />

ç¬¬äºŒè½®ï¼Œå¯¹æ¯”ä¸¤èŠ‚ç‚¹ `key` ä¸ç›¸åŒï¼Œ`updateSlot` è¿”å› `null`ï¼Œ`newFiber === null`ï¼Œ ç›´æ¥è·³å‡ºå¾ªç¯ï¼š

<img src="assets/image-20210329200827658.png" alt="image-20210329200827658" style="zoom:50%;" />

#### 2.4.2 ç¬¬äºŒä¸ªå¾ªç¯

ç¬¬ä¸€ä¸ªå¾ªç¯ä¼šåœ¨ç¢°åˆ°ç¬¬ä¸€ä¸ªæ— æ³•é‡å»ºæˆ–è€…é‡ç”¨çš„`fiber`èŠ‚ç‚¹(ä¹±åºã€`key\tag`ä¸ä¸€è‡´ã€`etc`)çš„æ—¶å€™é€€å‡ºã€‚å¯èƒ½æœ‰ä¸‹é¢ä¸¤ç§ç®€å•æƒ…å†µï¼š

+ å…¨éƒ¨èŠ‚ç‚¹éƒ½èµ°å®Œäº† `newIdx === newChildren.length`ï¼Œæ­¤æ—¶åˆ é™¤æ‰€æœ‰å‰©ä½™çš„ `oldFiber`ï¼Œè¿”å› `resultingFirstChild`ã€‚
+ `oldFiber`  èµ°å®Œäº†ï¼Œ`newChildren` å…¨éƒ¨æ–°å»º `fiber` å¹¶ä¸”æ’å…¥åˆ° `resultingFirstChild` ä¸­è¿”å›ã€‚

```ts
// ...
		if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        const newFiber = createChild(
          returnFiber,
          newChildren[newIdx],
          expirationTime,
        );
        if (!newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
      return resultingFirstChild;
    }
//...
```

#### 2.4.3 ç¬¬ä¸‰ä¸ªå¾ªç¯

è¿˜æœ‰æœ€åä¸€ç§è¾ƒä¸ºå¤æ‚çš„æƒ…å†µå°±æ˜¯ä¸¤ä¸ªéƒ½æ²¡èµ°å®Œï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨ä¸€ç§ç®—æ³•æ¥è®© `oldFiber` ä¸­ `key` å’Œ `newChildren` ä¸€è‡´çš„è¿›è¡Œå¿«é€ŸåŒ¹é…ï¼Œåˆ†ä¸ºå¦‚ä¸‹ä¸¤ä¸ªæ­¥éª¤ï¼š

+ `mapRemainingChildren(returnFiber, oldFiber);`ç»™å‰©ä½™çš„ `oldFibers` é€šè¿‡ `key` æˆ–è€… `index` åšä¸€ä¸ªæ˜ å°„ã€‚
+ ä¹‹åé¡ºåºéå† `newChildren`ï¼Œä½¿ç”¨`updateFromMap`åˆ›å»ºæ–° `fiber` æˆ–è€…æ›´æ–°è€ `fiber`ï¼Œæ€»ä¹‹åªè¦ `newChildren` æ˜¯åˆæ³•çš„å°±å¯ä»¥åˆ›å»º `fiber`ã€‚
+ ä¹‹åæ ¹æ® `newFiber` çš„ `key` æˆ–è€… `idx` åˆ é™¤ `oldfiber`ã€‚
+ `placeChild` å¯¹ `newFiber` è¿›è¡Œç§»åŠ¨ã€‚
+ å°†æ–°çš„ `newFiber` åŠ å…¥åˆ° `resultingFirstChild` ä¸­ã€‚

```ts
//...
    // Add all children to a key map for quick lookups.
    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        expirationTime,
      );
      if (newFiber) {
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(
              newFiber.key === null ? newIdx : newFiber.key,
            );
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
// ...
```

æœ€åé˜²æ­¢è€çš„ `oldfiber` æ¯”è¾ƒå¤š(æ¯” `newChildren`)ï¼Œè¿˜è¦å†éå† `existingChildren` èµ¶å°½æ€ç»ã€‚

```ts
    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(child => deleteChild(returnFiber, child));
    }

    return resultingFirstChild;
  }
```

æœ€åè¿”å› `resultingFirstChild` å°±æ˜¯æ–°çš„ `child` é“¾æ¡äº†ã€‚

**æ —å­ ğŸŒ°**

ç¬¬ä¸€æ­¥å…ˆæ ¹æ® `oldFiber` çš„ `index` å’Œ `key` åšä¸€ä¸ªèŠ‚ç‚¹æ˜ å°„ï¼Œä¹‹åä» `newChild` åšåŒ¹é…ï¼Œå¯¹äº `key: e`æ²¡æ‹¿åˆ°ä»»ä½•çš„å¯¹åº”èŠ‚ç‚¹ï¼Œæ‰€ä»¥` Placement` ä¸€ä¸ª `newFiber`ï¼š

![image-20210329195005094](assets/image-20210329195005094.png)

ä¹‹ååˆ°äº† `key: d` åœ¨` map`é‡Œé¢æ‰¾åˆ°äº†å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå°è¯•å¹¶ä¸”æˆåŠŸå¤ç”¨èŠ‚ç‚¹ï¼Œ`placeChild`çš„æ—¶å€™å›æ›´æ–° `lastPlaceIdx = 3`ï¼Œä¹Ÿå°±æ˜¯ `oldFiber` ä¸Šçš„ `index`ï¼Œç°åœ¨æˆ‘ä»¬çŸ¥é“äº†è¿™ä¸ªå±€éƒ¨å˜é‡çš„å«ä¹‰ `lastPlaceIdxï¼šç›®å‰æœ€åä¸€ä¸ªå¤ç”¨çš„èŠ‚ç‚¹id`ï¼Œä¹Ÿå°±æ˜¯è¯´åªè¦å¤ç”¨èŠ‚ç‚¹çš„ `index` æ¯” `lastPlaceIdx`å¤§ï¼Œå°±è¯´æ˜æ²¡æœ‰ä¹±åºã€‚

![image-20210329200728615](assets/image-20210329200728615.png)

æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ŒåŒæ ·åœ¨æ˜ å°„é‡Œé¢æ‰¾åˆ°ï¼Œå¹¶ä¸”å¯ä»¥å¤ç”¨ã€‚ä½†æ˜¯ `placeChild` ä¸­ç”±äº `lastPlaceIdxï¼šç›®å‰æœ€åä¸€ä¸ªå¤ç”¨çš„èŠ‚ç‚¹id` æ¯”è¿™ä¸ªå¤ç”¨çš„èŠ‚ç‚¹çš„ `id`è¦å¤§ï¼Œè¯´æ˜ä¹±åºäº†ï¼Œæ‰€ä»¥è¦æ ‡è®° `Placement`ã€‚

![image-20210329200804834](assets/image-20210329200804834.png)

æœ€åçš„æ„å»ºç»“æœå°±æ˜¯è¿™ä¸ªæ ·å­çš„ï¼Œæ–°è€` fiberTree`å·®å¼‚å¾ˆå¤§ï¼Œæœ€ååœ¨ `commit`é˜¶æ®µä¼šæ ¹æ® `Deletetion`åˆ é™¤æ‰ `<p>`ï¼Œç„¶åæ ¹æ® `Placement` æ”¹å˜ `dom` èŠ‚ç‚¹ä½ç½®ï¼š

<img src="assets/image-20210329202302294.png" alt="image-20210329202302294" style="zoom:80%;" />

#### 2.4.1 updateSlot

`updateSlot` æ˜¯ `reconcileChildrenArray` ç”¨æ¥æ‰§è¡Œå•å…ƒä»»åŠ¡çš„ï¼Œå®ƒæ¯”è¾ƒ `oldFiber` å’Œ `newChild`ï¼Œå¦‚æœ `key` ç›¸åŒåˆ™æ›´æ–°ï¼Œä¸ç„¶è¿”å› `null`ï¼š

ç¬¬ä¸€ç§æƒ…å†µä¸­ `old` å’Œ `new` éƒ½éƒ½æ²¡æœ‰ `key`ï¼Œå¹¶ä¸” `newChild` è¿˜æ˜¯ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ï¼Œé‚£å°±èµ° `updateTextNode` å…¶å†…éƒ¨ä¼šå†³å®šæ˜¯é‡å»ºè¿˜æ˜¯æ›´æ–°ï¼š

```ts
  function updateSlot(
    returnFiber: Fiber,
    oldFiber: Fiber | null,
    newChild: any,
    expirationTime: ExpirationTime,
  ): Fiber | null {
    // Update the fiber if the keys match, otherwise return null.

    const key = oldFiber !== null ? oldFiber.key : null;
    // å¦‚æœä¹±åºäº†è¿™é‡Œæ˜¯ä¸ä¼šæœ‰ key çš„
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(
        returnFiber,
        oldFiber,
        '' + newChild,
        expirationTime,
      );
    }
//...
```

ä¹‹åéƒ½æœ‰ `key` çš„æƒ…å†µå°±å¯¹ `$$typeof` åšä¸€ä¸ªåˆ¤æ–­ï¼Œå…·ä½“çš„æ›´æ–°çš„é€»è¾‘ç»†åŒ–åˆ°  `updateFragment`ã€`updateElement`ã€`updatePortal` ä¸­ã€‚

```ts
//...
    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          if (newChild.key === key) {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(
                returnFiber,
                oldFiber,
                newChild.props.children,
                expirationTime,
                key,
              );
            }
            return updateElement(
              returnFiber,
              oldFiber,
              newChild,
              expirationTime,
            );
          } else {
            return null;
          }
        }
        case REACT_PORTAL_TYPE: {
          if (newChild.key === key) {
            return updatePortal(
              returnFiber,
              oldFiber,
              newChild,
              expirationTime,
            );
          } else {
            return null;
          }
        }
      }

      if (isArray(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(
          returnFiber,
          oldFiber,
          newChild,
          expirationTime,
          null,
        );
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
```

#### 2.4.2 updateTextNode

`current` ä¸º `null` æˆ–è€… `current.tag !== HostText` éƒ½è¡¨ç¤º `current` ä¸èƒ½å¤ç”¨ä¸º `TextNode` æ­¤æ—¶éœ€è¦æ–°å»ºï¼Œå¦åˆ™å¯ä»¥ä½¿ç”¨ `useFiber` å¤ç”¨ã€‚

```ts
  function updateTextNode(
    returnFiber: Fiber,
    current: Fiber | null,
    textContent: string,
    expirationTime: ExpirationTime,
  ) {
    if (current === null || current.tag !== HostText) {
      // Insert
      const created = createFiberFromText(
        textContent,
        returnFiber.mode,
        expirationTime,
      );
      created.return = returnFiber;
      return created;
    } else {
      // Update
      const existing = useFiber(current, textContent, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }
```

#### 2.4.3 updateElement

å’Œä¸Šé¢çš„ç±»ä¼¼ï¼Œåªæ˜¯å¯å¤ç”¨æ¡ä»¶å˜æˆäº† `current.elementType === element.type`ï¼š

```ts
  function updateElement(
    returnFiber: Fiber,
    current: Fiber | null,
    element: ReactElement,
    expirationTime: ExpirationTime,
  ): Fiber {
    if (current !== null && current.elementType === element.type) {
      // Move based on index
      const existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(returnFiber, current, element);
      existing.return = returnFiber;
      return existing;
    } else {
      // Insert
      const created = createFiberFromElement(
        element,
        returnFiber.mode,
        expirationTime,
      );
      created.ref = coerceRef(returnFiber, current, element);
      created.return = returnFiber;
      return created;
    }
  }
```

#### 2.4.4 updateFragment

å’Œä¸Šé¢çš„ç±»ä¼¼ï¼Œåªæ˜¯å¯å¤ç”¨æ¡ä»¶å˜æˆäº† `current.tag == Fragment`ï¼š

```ts
  function updateFragment(
    returnFiber: Fiber,
    current: Fiber | null,
    fragment: Iterable<*>,
    expirationTime: ExpirationTime,
    key: null | string,
  ): Fiber {
    if (current === null || current.tag !== Fragment) {
      // Insert
      const created = createFiberFromFragment(
        fragment,
        returnFiber.mode,
        expirationTime,
        key,
      );
      created.return = returnFiber;
      return created;
    } else {
      // Update
      const existing = useFiber(current, fragment, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }
```

#### 2.4.5 placeChild

å¦‚æœè¿™ä¸ª `newFiber` æ˜¯æ›´æ–°æ¥çš„ï¼Œé‚£ä¹ˆæ¯”è¾ƒä»–å’Œ `oldFiber` çš„ä½ç½®å…³ç³»(é€šè¿‡ `alternate`)ï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹æ˜¯æ–°æ’å…¥çš„ï¼Œæˆ–è€…ä»–ç§»åŠ¨è¿‡ï¼Œé‚£å°±æ ‡è®° `effectTag` ä¸º `Placement`ã€‚

åœ¨è¿™é‡Œæˆ‘ä»¬çŸ¥é“äº† `lastPlacedIndex` çš„å«ä¹‰ï¼Œ `lastPlaceIdxï¼šç›®å‰æœ€åä¸€ä¸ªå¤ç”¨ä¸”æ²¡ä¹±åºçš„èŠ‚ç‚¹id`ï¼Œæ¯æ¬¡ç¢°åˆ°å¤ç”¨èŠ‚ç‚¹å¦‚æœæ²¡ä¹±åºå°±ä¼šæ›´æ–°è¿™ä¸ªå˜é‡ï¼Œè®°å½•ç›®å‰å¤ç”¨çš„æœ€å¤§ `idx`ï¼Œ`oldFiber.index < lastPlaceIdx`å°±è¯´æ˜ä¹±åºäº†ã€‚

```ts
  function placeChild(
    newFiber: Fiber,
    lastPlacedIndex: number,
    newIndex: number,
  ): number {
    newFiber.index = newIndex;
    // è®¾ç½® index
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    const current = newFiber.alternate;
    if (current !== null) {
      const oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }
```

#### 2.4.6 mapRemainingChildren

ç»™å‰©ä½™çš„ `oldFibers` é€šè¿‡ `key` æˆ–è€… `index` åšä¸€ä¸ªæ˜ å°„ã€‚

```ts
  function mapRemainingChildren(
    returnFiber: Fiber,
    currentFirstChild: Fiber,
  ): Map<string | number, Fiber> {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    // instead.
    const existingChildren: Map<string | number, Fiber> = new Map();

    let existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

```

#### 2.4.7 updateFromMap

è¿™ä¸ªæ–¹æ³•å’Œ `updateSlot` å®åœ¨æ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œæˆ‘éƒ½ä¸æƒ³å†™ä¸‹æ¥äº†ï¼Œå°±æ˜¯åˆ¤æ–­ä¸€ä¸‹æœ‰æ²¡æœ‰ç›¸åŒ`key` æˆ–è€…  `idx` çš„è€èŠ‚ç‚¹ç„¶åæ„é€ æ–°èŠ‚ç‚¹æˆ–è€…æ›´æ–°è€èŠ‚ç‚¹ã€‚

```ts
  function updateFromMap(
    existingChildren: Map<string | number, Fiber>,
    returnFiber: Fiber,
    newIdx: number,
    newChild: any,
    expirationTime: ExpirationTime,
  ): Fiber | null {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      const matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(...);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const matchedFiber =
            existingChildren.get(
              newChild.key === null ? newIdx : newChild.key,
            ) || null;
          if (newChild.type === REACT_FRAGMENT_TYPE) {
            return updateFragment(...);
          }
          return updateElement(...);
        }
        case REACT_PORTAL_TYPE: {
          const matchedFiber =
            existingChildren.get(
              newChild.key === null ? newIdx : newChild.key,
            ) || null;
          return updatePortal(...);
        }
      }

      if (isArray(newChild) || getIteratorFn(newChild)) {
        const matchedFiber = existingChildren.get(newIdx) || null;
        return updateFragment(...);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }

```

